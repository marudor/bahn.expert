// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * RIS :: Journeys
 * ## Info * member of the **[RIS-API](https://db-planet.deutschebahn.com/pages/reisendeninformation-ris-api)** family * powered by [TR Reisendeninformationen](https://db-planet.deutschebahn.com/pages/reisendeninformation/apps/content/willkommen) * implements model: 1.0.206-SNAPSHOT  ## Capabilities Provides detailed information for a particular journey [Fahrt], including: * transport type [Produktklasse], category [Fahrtgattung], line [Linie], administration [Verwaltung] and operator [Betreiber] * origin [Starthalt] and destination [Zielhalt] * departues [Abfahrten] or arrivals [Ankuenfte] (depending on board) with schedule [Soll] and forecast [Vorschau] times and platforms [Plattform / Gleis / Bussteig etc.] * canceld stops [Haltausfall], additional stops [Zusatzhalt], additional textual information [Freitexte] and possible restrictions on changing passengers [Fahrgastwechsel] * references to other transports representing replacement [Ersatz], relief [Entlastung], travels with [Vereinigung] and continuation [Durchbindung] * disruptions [St√∂rungen] for journey, arrivals and departures  The consumer can choose a segment based [Fahrtabschnittsbasiert] or an event based [Fahrtereignisbasiert] view.  Requests are usually stated using a journey ID defined by TR. In addition journeys and partiuclar departures [Abfahrten] can be matched by providing data like category [Fahrtgattung], number [Fahrtnummer] and administration ID [VerwaltungsID].   ## Limitations * journeys are limited to 22 hours ahead  ## Getting Started * get to know the vision behind [RIS-API](https://db-planet.deutschebahn.com/pages/reisendeninformation-ris-api/apps/content/inhalt) * learn how to [get started](https://db-planet.deutschebahn.com/pages/reisendeninformation-ris-api/apps/content/openapi-beispiele) for your programming language of desire
 *
 * The version of the OpenAPI document: 1.1.82
 * Contact: ris-fachbetrieb@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 * Information on the operator [Betreiber] and the administration [Verwaltung] of the journey.
 * @export
 * @interface Administration
 */
export interface Administration {
  /**
   * Unique id of the administration [Verwaltung].
   * @type {string}
   * @memberof Administration
   */
  administrationID: string;
  /**
   * Unique code of the operator [Betreiber].
   * @type {string}
   * @memberof Administration
   */
  operatorCode: string;
  /**
   * Name of the operator [Betreiber].
   * @type {string}
   * @memberof Administration
   */
  operatorName: string;
}
/**
 * Information on journey arrival [Ankunft].
 * @export
 * @interface Arrival
 */
export interface Arrival {
  /**
   * Unique id for arrival [AnkunftsID].
   * @type {string}
   * @memberof Arrival
   */
  arrivalID: string;
  /**
   * List of disruptions [Stoerungsinformationen] for journey at this particular stop.
   * @type {Array<DisruptionCommunicationEmbedded>}
   * @memberof Arrival
   */
  disruptions?: Array<DisruptionCommunicationEmbedded>;
  /**
   * List of messages [Freitexte] for journey at this particular stop [Freitexte].
   * @type {Array<Message>}
   * @memberof Arrival
   */
  messages: Array<Message>;
  /**
   * Indicates whether passengers are allowed to enter / leave [Fahrgastwechsel].
   * @type {boolean}
   * @memberof Arrival
   */
  passengerChange: boolean;
  /**
   * Actual platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof Arrival
   */
  platform: string;
  /**
   * Scheduled platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof Arrival
   */
  platformSchedule?: string;
  /**
   *
   * @type {StationShort}
   * @memberof Arrival
   */
  station: StationShort;
  /**
   * Best known time information of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof Arrival
   */
  time: string;
  /**
   * Scheduled time [Soll] of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof Arrival
   */
  timeSchedule: string;
  /**
   *
   * @type {TimeType}
   * @memberof Arrival
   */
  timeType: TimeType;
}
/**
 * Journey event [Fahrtereignis].
 * @export
 * @interface ArrivalDepartureEvent
 */
export interface ArrivalDepartureEvent {
  /**
   * Indicates whether this event is additional, meaning not be part of the regular schedule.
   * @type {boolean}
   * @memberof ArrivalDepartureEvent
   */
  additional: boolean;
  /**
   *
   * @type {Administration}
   * @memberof ArrivalDepartureEvent
   */
  administration: Administration;
  /**
   * ID of arrival or departure, depends on event type.
   * @type {string}
   * @memberof ArrivalDepartureEvent
   */
  arrivalOrDepartureID: string;
  /**
   * Indicates whether this event has been canceled.
   * @type {boolean}
   * @memberof ArrivalDepartureEvent
   */
  canceled: boolean;
  /**
   * List of disruptions [Stoerungsinformationen] for journey at this particular stop.
   * @type {Array<DisruptionCommunicationEmbedded>}
   * @memberof ArrivalDepartureEvent
   */
  disruptions?: Array<DisruptionCommunicationEmbedded>;
  /**
   * List of messages [Freitexte] for journey at this particular stop [Freitexte].
   * @type {Array<Message>}
   * @memberof ArrivalDepartureEvent
   */
  messages: Array<Message>;
  /**
   * Indicates whether passengers are allowed to enter / leave [Fahrgastwechsel].
   * @type {boolean}
   * @memberof ArrivalDepartureEvent
   */
  passengerChange: boolean;
  /**
   * Actual platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof ArrivalDepartureEvent
   */
  platform: string;
  /**
   * Scheduled platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof ArrivalDepartureEvent
   */
  platformSchedule?: string;
  /**
   * List of transports this journey at this particular event is reliefed by [Entlastungszug].
   * @type {Array<TransportPublicDestinationOriginJourney>}
   * @memberof ArrivalDepartureEvent
   */
  reliefBy: Array<TransportPublicDestinationOriginJourney>;
  /**
   * List of transports this journey at this particular event reliefs for [Entlastungszug].
   * @type {Array<TransportPublicDestinationOriginJourney>}
   * @memberof ArrivalDepartureEvent
   */
  reliefFor: Array<TransportPublicDestinationOriginJourney>;
  /**
   * List of transports this journey at this particular event is replaced by [Ersatzzug].
   * @type {Array<TransportPublicDestinationOriginJourney>}
   * @memberof ArrivalDepartureEvent
   */
  replacedBy: Array<TransportPublicDestinationOriginJourney>;
  /**
   * List of transports this journey at this particular event replaces [Ersatzzug].
   * @type {Array<TransportPublicDestinationOriginJourney>}
   * @memberof ArrivalDepartureEvent
   */
  replacementFor: Array<TransportPublicDestinationOriginJourney>;
  /**
   *
   * @type {StationShort}
   * @memberof ArrivalDepartureEvent
   */
  station: StationShort;
  /**
   * Best known time information of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof ArrivalDepartureEvent
   */
  time: string;
  /**
   * Scheduled time [Soll] of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof ArrivalDepartureEvent
   */
  timeSchedule: string;
  /**
   *
   * @type {TimeType}
   * @memberof ArrivalDepartureEvent
   */
  timeType: TimeType;
  /**
   *
   * @type {TransportPublic}
   * @memberof ArrivalDepartureEvent
   */
  transport: TransportPublic;
  /**
   * List of journeys this journey at this particular event travels with [Vereinigt Mit].
   * @type {Array<TransportPublicDestinationOriginJourney>}
   * @memberof ArrivalDepartureEvent
   */
  travelsWith: Array<TransportPublicDestinationOriginJourney>;
  /**
   *
   * @type {EventType}
   * @memberof ArrivalDepartureEvent
   */
  type: EventType;
}
/**
 * Information on journey departure [Abfahrt].
 * @export
 * @interface Departure
 */
export interface Departure {
  /**
   * Unique id for departure [AbfahrtID].
   * @type {string}
   * @memberof Departure
   */
  departureID: string;
  /**
   * List of disruptions [Stoerungsinformationen] for journey at this particular stop.
   * @type {Array<DisruptionCommunicationEmbedded>}
   * @memberof Departure
   */
  disruptions?: Array<DisruptionCommunicationEmbedded>;
  /**
   * List of messages [Freitexte] for journey at this particular stop [Freitexte].
   * @type {Array<Message>}
   * @memberof Departure
   */
  messages: Array<Message>;
  /**
   * Indicates whether passengers are allowed to enter / leave [Fahrgastwechsel].
   * @type {boolean}
   * @memberof Departure
   */
  passengerChange: boolean;
  /**
   * Actual platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof Departure
   */
  platform: string;
  /**
   * Scheduled platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof Departure
   */
  platformSchedule?: string;
  /**
   *
   * @type {StationShort}
   * @memberof Departure
   */
  station: StationShort;
  /**
   * Best known time information of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof Departure
   */
  time: string;
  /**
   * Scheduled time [Soll] of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof Departure
   */
  timeSchedule: string;
  /**
   *
   * @type {TimeType}
   * @memberof Departure
   */
  timeType: TimeType;
}
/**
 * Departure [Abfahrt] match.
 * @export
 * @interface DepartureMatch
 */
export interface DepartureMatch {
  /**
   * Unique id for administration [Verwaltung] at departure.
   * @type {string}
   * @memberof DepartureMatch
   */
  administrationID: string;
  /**
   * ID of departure [AbfahrtID]
   * @type {string}
   * @memberof DepartureMatch
   */
  departureID: string;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof DepartureMatch
   */
  journeyID: string;
  /**
   * Actual platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof DepartureMatch
   */
  platform?: string;
  /**
   * Scheduled platform [Gleis, Bahnsteig, Plattform] the transport arrives / departs at.
   * @type {string}
   * @memberof DepartureMatch
   */
  platformSchedule?: string;
  /**
   *
   * @type {StationShort}
   * @memberof DepartureMatch
   */
  station: StationShort;
  /**
   * Best known time information of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof DepartureMatch
   */
  time: string;
  /**
   * Scheduled time [Soll] of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof DepartureMatch
   */
  timeSchedule: string;
  /**
   *
   * @type {TimeType}
   * @memberof DepartureMatch
   */
  timeType: TimeType;
  /**
   *
   * @type {TransportPublic}
   * @memberof DepartureMatch
   */
  transport: TransportPublic;
}
/**
 * List of possible departure [Abfahrt] matches.
 * @export
 * @interface DepartureMatches
 */
export interface DepartureMatches {
  /**
   * Matched departures.
   * @type {Array<DepartureMatch>}
   * @memberof DepartureMatches
   */
  departures: Array<DepartureMatch>;
}
/**
 * Disruption communication information [Stoerungskommunikation] descriptions.
 * @export
 * @interface DisruptionCommunicationDescription
 */
export interface DisruptionCommunicationDescription {
  /**
   * Long text of disruption communication.
   * @type {string}
   * @memberof DisruptionCommunicationDescription
   */
  text: string;
  /**
   * Optional short text of disruption communication.
   * @type {string}
   * @memberof DisruptionCommunicationDescription
   */
  textShort?: string;
}
/**
 * Embedded disruption communication information [Stoerungskommunikation].
 * @export
 * @interface DisruptionCommunicationEmbedded
 */
export interface DisruptionCommunicationEmbedded {
  /**
   * Textual short description of disruption by language identifier.
   * @type {{ [key: string]: DisruptionCommunicationDescription; }}
   * @memberof DisruptionCommunicationEmbedded
   */
  descriptions: { [key: string]: DisruptionCommunicationDescription };
  /**
   * Display priority [Anzeigereihenfolge] for disruption. Order is by display priority asc. May be empty.
   * @type {number}
   * @memberof DisruptionCommunicationEmbedded
   */
  displayPriority?: number;
  /**
   * ID of disruption [StoerungsID].
   * @type {string}
   * @memberof DisruptionCommunicationEmbedded
   */
  disruptionID: string;
}
/**
 * Detailed error information on field level.
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorDetail
   */
  detail: string;
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorDetail
   */
  errorCode?: number;
  /**
   * Name of field / element that raised the error.
   * @type {string}
   * @memberof ErrorDetail
   */
  field: string;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorDetail
   */
  title: string;
}
/**
 * API error object conforming to RFC7807.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorResponse
   */
  detail: string;
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorResponse
   */
  errorCode?: number;
  /**
   * List of detailed errors in case multiple errors have lead to the surrounding error.
   * @type {Array<ErrorDetail>}
   * @memberof ErrorResponse
   */
  errors?: Array<ErrorDetail>;
  /**
   * Unique identifier for instance that raised the error.
   * @type {string}
   * @memberof ErrorResponse
   */
  instanceId?: string;
  /**
   * Http status for error origin.
   * @type {number}
   * @memberof ErrorResponse
   */
  status?: number;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorResponse
   */
  title: string;
}
/**
 * Type of event. Can be arrival or departure. - ARRIVAL (Ankunft) - DEPARTURE (Abfahrt)
 * @export
 * @enum {string}
 */

export const EventType = {
  Arrival: 'ARRIVAL',
  Departure: 'DEPARTURE',
} as const;

export type EventType = typeof EventType[keyof typeof EventType];

/**
 * Event based [Fahrtereignisbasiert] information for a particular journey [Fahrtverlauf].
 * @export
 * @interface JourneyEventBased
 */
export interface JourneyEventBased {
  /**
   *
   * @type {TransportPublicDestination}
   * @memberof JourneyEventBased
   */
  continuationBy?: TransportPublicDestination;
  /**
   *
   * @type {TransportPublicOrigin}
   * @memberof JourneyEventBased
   */
  continuationFor?: TransportPublicOrigin;
  /**
   *
   * @type {StationShort}
   * @memberof JourneyEventBased
   */
  destinationSchedule: StationShort;
  /**
   * List of disruptions [Stoerungsinformationen] for whole journey.
   * @type {Array<DisruptionCommunicationEmbedded>}
   * @memberof JourneyEventBased
   */
  disruptions?: Array<DisruptionCommunicationEmbedded>;
  /**
   * List of events [Fahrtereignisse]. Order is based on 1 - scheduled time and 2 - arrival before departure.
   * @type {Array<ArrivalDepartureEvent>}
   * @memberof JourneyEventBased
   */
  events: Array<ArrivalDepartureEvent>;
  /**
   * Flag that indicates whether whole journey has been canceled.
   * @type {boolean}
   * @memberof JourneyEventBased
   */
  journeyCanceled: boolean;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof JourneyEventBased
   */
  journeyID: string;
  /**
   *
   * @type {StationShort}
   * @memberof JourneyEventBased
   */
  originSchedule: StationShort;
  /**
   *
   * @type {JourneyType}
   * @memberof JourneyEventBased
   */
  type: JourneyType;
}
/**
 * Journey [Fahrt] match.
 * @export
 * @interface JourneyMatch
 */
export interface JourneyMatch {
  /**
   * Unique id for administration [Verwaltung].
   * @type {string}
   * @memberof JourneyMatch
   */
  administrationID: string;
  /**
   * Date of scheduled start departure of journey [Verkehrstag].
   * @type {string}
   * @memberof JourneyMatch
   */
  date: string;
  /**
   *
   * @type {StationShort}
   * @memberof JourneyMatch
   */
  destinationSchedule: StationShort;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof JourneyMatch
   */
  journeyID: string;
  /**
   *
   * @type {StationShort}
   * @memberof JourneyMatch
   */
  originSchedule: StationShort;
  /**
   *
   * @type {TransportPublic}
   * @memberof JourneyMatch
   */
  transport: TransportPublic;
}
/**
 * List of possible journey [Fahrt] matches.
 * @export
 * @interface JourneyMatches
 */
export interface JourneyMatches {
  /**
   * Matched journeys.
   * @type {Array<JourneyMatch>}
   * @memberof JourneyMatches
   */
  journeys: Array<JourneyMatch>;
}
/**
 * Segment based [Fahrtabschnittsbasiert] information for a particular journey [Fahrtverlauf].
 * @export
 * @interface JourneySegmentBased
 */
export interface JourneySegmentBased {
  /**
   *
   * @type {TransportPublicDestination}
   * @memberof JourneySegmentBased
   */
  continuationBy?: TransportPublicDestination;
  /**
   *
   * @type {TransportPublicOrigin}
   * @memberof JourneySegmentBased
   */
  continuationFor?: TransportPublicOrigin;
  /**
   *
   * @type {StationShort}
   * @memberof JourneySegmentBased
   */
  destinationSchedule: StationShort;
  /**
   * List of disruptions [Stoerungsinformationen] for whole journey.
   * @type {Array<DisruptionCommunicationEmbedded>}
   * @memberof JourneySegmentBased
   */
  disruptions?: Array<DisruptionCommunicationEmbedded>;
  /**
   * Flag that indicates whether whole journey has been canceled.
   * @type {boolean}
   * @memberof JourneySegmentBased
   */
  journeyCanceled?: boolean;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof JourneySegmentBased
   */
  journeyID: string;
  /**
   *
   * @type {StationShort}
   * @memberof JourneySegmentBased
   */
  originSchedule: StationShort;
  /**
   * List of segments [Fahrtabschnitte].
   * @type {Array<Segment>}
   * @memberof JourneySegmentBased
   */
  segments?: Array<Segment>;
  /**
   * List of canceled segments [Fahrtabschnitte].
   * @type {Array<SegmentCanceled>}
   * @memberof JourneySegmentBased
   */
  segmentsCanceled?: Array<SegmentCanceled>;
  /**
   *
   * @type {JourneyType}
   * @memberof JourneySegmentBased
   */
  type: JourneyType;
}
/**
 * Defines whether journey [Fahrt] is regular or some kind of special. - REGULAR (Regular scheduled journey) - REPLACEMENT (Journey that replaces another journey) - RELIEF (Journey that reliefs another journey) - EXTRA (Journey that is somehow extra
 * @export
 * @enum {string}
 */

export const JourneyType = {
  Regular: 'REGULAR',
  Replacement: 'REPLACEMENT',
  Relief: 'RELIEF',
  Extra: 'EXTRA',
} as const;

export type JourneyType = typeof JourneyType[keyof typeof JourneyType];

/**
 * Message for customers and or employees, depends on type.
 * @export
 * @interface Message
 */
export interface Message {
  /**
   * Optional category of message, like for instance \'Bauarbeiten\' or \'Informationen\'
   * @type {string}
   * @memberof Message
   */
  category?: string;
  /**
   * Unique code of message may be empty in case of HIM based messages.
   * @type {string}
   * @memberof Message
   */
  code?: string;
  /**
   * Display priority [Anzeigereihenfolge] for message. Order is by display priority asc. May be empty.
   * @type {number}
   * @memberof Message
   */
  displayPriority?: number;
  /**
   * Freetext of message.
   * @type {string}
   * @memberof Message
   */
  text: string;
  /**
   * Short freetext of message, may be empty.
   * @type {string}
   * @memberof Message
   */
  textShort?: string;
  /**
   *
   * @type {MessageType}
   * @memberof Message
   */
  type: MessageType;
}
/**
 * Classification of message. - CUSTOMER_TEXT (unstructured free text [unstrukturierter Kundenfreitext], may be based on HIM messages (no disruptions!) (for instance \'Bitte beachten Sie die Maskenpflicht\') - QUALITY_VARIATION (structured quality variations [struckturierte Qualit√§tsabweichung] (for instance \'Ge√§nderte Wagenreihung\' or \'Fahrradmitnahme nicht m√∂glich\') - CUSTOMER_REASON (structured customer reasons [struckturierte Kundenbegr√ºndungen] (for instance \'Umgest√ºrzter Baum auf Strecke\' or \'Versp√§tung aufgrund vorausfahrendem Zug\')
 * @export
 * @enum {string}
 */

export const MessageType = {
  CustomerText: 'CUSTOMER_TEXT',
  QualityVariation: 'QUALITY_VARIATION',
  CustomerReason: 'CUSTOMER_REASON',
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];

/**
 * Journey segment information on departure and arrival [Fahrtabschnitt].
 * @export
 * @interface Segment
 */
export interface Segment {
  /**
   * Indicates whether this segment is additional, meaning not be part of the regular schedule.
   * @type {boolean}
   * @memberof Segment
   */
  additional: boolean;
  /**
   *
   * @type {Administration}
   * @memberof Segment
   */
  administration: Administration;
  /**
   *
   * @type {Arrival}
   * @memberof Segment
   */
  arrival: Arrival;
  /**
   * Indicates whether this segment has been canceled.
   * @type {boolean}
   * @memberof Segment
   */
  canceled: boolean;
  /**
   *
   * @type {Departure}
   * @memberof Segment
   */
  departure: Departure;
  /**
   * List of transports this journey at this particular segment is reliefed by [Entlastungszug].
   * @type {Array<TransportPublicDestination>}
   * @memberof Segment
   */
  reliefBy?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment reliefs for [Entlastungszug].
   * @type {Array<TransportPublicDestination>}
   * @memberof Segment
   */
  reliefFor?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment is replaced by [Ersatzzug].
   * @type {Array<TransportPublicDestination>}
   * @memberof Segment
   */
  replacedBy?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment replaces [Ersatzzug].
   * @type {Array<TransportPublicDestination>}
   * @memberof Segment
   */
  replacementFor?: Array<TransportPublicDestination>;
  /**
   *
   * @type {TransportPublic}
   * @memberof Segment
   */
  transport: TransportPublic;
  /**
   * List of journeys this journey at this particular segment travels with [Traktionen].
   * @type {Array<TransportPublicDestination>}
   * @memberof Segment
   */
  travelsWith?: Array<TransportPublicDestination>;
}
/**
 * Reflects a canceled segment.
 * @export
 * @interface SegmentCanceled
 */
export interface SegmentCanceled {
  /**
   * Indicates whether this segment is additional, meaning not be part of the regular schedule.
   * @type {boolean}
   * @memberof SegmentCanceled
   */
  additional: boolean;
  /**
   *
   * @type {Administration}
   * @memberof SegmentCanceled
   */
  administration: Administration;
  /**
   *
   * @type {Arrival}
   * @memberof SegmentCanceled
   */
  arrival: Arrival;
  /**
   * Indicates whether this segment has been canceled.
   * @type {boolean}
   * @memberof SegmentCanceled
   */
  canceled: boolean;
  /**
   *
   * @type {Departure}
   * @memberof SegmentCanceled
   */
  departure: Departure;
  /**
   * List of transports this journey at this particular segment is reliefed by [Entlastungszug].
   * @type {Array<TransportPublicDestination>}
   * @memberof SegmentCanceled
   */
  reliefBy?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment reliefs for [Entlastungszug].
   * @type {Array<TransportPublicDestination>}
   * @memberof SegmentCanceled
   */
  reliefFor?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment is replaced by [Ersatzzug].
   * @type {Array<TransportPublicDestination>}
   * @memberof SegmentCanceled
   */
  replacedBy?: Array<TransportPublicDestination>;
  /**
   * List of transports this journey at this particular segment replaces [Ersatzzug].
   * @type {Array<TransportPublicDestination>}
   * @memberof SegmentCanceled
   */
  replacementFor?: Array<TransportPublicDestination>;
  /**
   * References to departure ID this segment was positioned before. May reference to a canceled segment as well and may be empty in case of destination.
   * @type {string}
   * @memberof SegmentCanceled
   */
  scheduledBeforeDepartureID: string;
  /**
   *
   * @type {TransportPublic}
   * @memberof SegmentCanceled
   */
  transport: TransportPublic;
  /**
   * List of journeys this journey at this particular segment travels with [Traktionen].
   * @type {Array<TransportPublicDestination>}
   * @memberof SegmentCanceled
   */
  travelsWith?: Array<TransportPublicDestination>;
}
/**
 * Comprehensive station [Bahnhof] information.
 * @export
 * @interface StationShort
 */
export interface StationShort {
  /**
   * Eva number of station.
   * @type {string}
   * @memberof StationShort
   */
  evaNumber: string;
  /**
   * Name for station in fixed language.
   * @type {string}
   * @memberof StationShort
   */
  name: string;
}
/**
 * Stop at a particular station [Bahnhof] for arrival / departure boards.
 * @export
 * @interface StopAtStation
 */
export interface StopAtStation {
  /**
   * Indicates whether the stop ie departure / arrival has been canceled [Haltausfall].
   * @type {boolean}
   * @memberof StopAtStation
   */
  canceled: boolean;
  /**
   * Eva number of station.
   * @type {string}
   * @memberof StopAtStation
   */
  evaNumber: string;
  /**
   * Name for station in fixed language.
   * @type {string}
   * @memberof StopAtStation
   */
  name: string;
}
/**
 * Specifies whether \'time\' is based on schedule or preview. - SCHEDULE (Time source is schedule) - PREVIEW (Time source is preview / forecast) - REAL (Time source is real)
 * @export
 * @enum {string}
 */

export const TimeType = {
  Schedule: 'SCHEDULE',
  Preview: 'PREVIEW',
  Real: 'REAL',
} as const;

export type TimeType = typeof TimeType[keyof typeof TimeType];

/**
 * Public transport description for all types of trains, buses, subways, trams etc.
 * @export
 * @interface TransportPublic
 */
export interface TransportPublic {
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublic
   */
  category: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublic
   */
  label?: string;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublic
   */
  line?: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublic
   */
  number: number;
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublic
   */
  type: TransportType;
}
/**
 * Public transport [Oeffentlicher Transport] with (scheduled) destination [Ziel] and differing destination in case the final stop of the journey changed [Haltausfall, Laufwegverl√§ngerung, ...].
 * @export
 * @interface TransportPublicDestination
 */
export interface TransportPublicDestination {
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  category: string;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicDestination
   */
  destination: StopAtStation;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicDestination
   */
  differingDestination?: StopAtStation;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  journeyID: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  label?: string;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  line?: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublicDestination
   */
  number: number;
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublicDestination
   */
  type: TransportType;
}
/**
 * Public transport reference [Oeffentlicher Verkehr Referenz] with origin [Herkunft] and destination [Ziel] information and journey id [FahrtID].
 * @export
 * @interface TransportPublicDestinationOriginJourney
 */
export interface TransportPublicDestinationOriginJourney {
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublicDestinationOriginJourney
   */
  category: string;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicDestinationOriginJourney
   */
  destination: StopAtStation;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicDestinationOriginJourney
   */
  differingDestination?: StopAtStation;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportPublicDestinationOriginJourney
   */
  journeyID: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublicDestinationOriginJourney
   */
  label?: string;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublicDestinationOriginJourney
   */
  line?: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublicDestinationOriginJourney
   */
  number: number;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicDestinationOriginJourney
   */
  origin: StopAtStation;
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublicDestinationOriginJourney
   */
  type: TransportType;
}
/**
 * Public transport [Oeffentlicher Transport] with origin [Herkunft].
 * @export
 * @interface TransportPublicOrigin
 */
export interface TransportPublicOrigin {
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  category: string;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicOrigin
   */
  differingOrigin?: StopAtStation;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  journeyID: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  label?: string;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  line?: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublicOrigin
   */
  number: number;
  /**
   *
   * @type {StopAtStation}
   * @memberof TransportPublicOrigin
   */
  origin: StopAtStation;
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublicOrigin
   */
  type: TransportType;
}
/**
 * Type of transport. - HIGH_SPEED_TRAIN (High speed train [Hochgeschwindigkeitszug] like ICE or TGV etc.) - INTERCITY_TRAIN (Inter city train [Intercityzug]) - INTER_REGIONAL_TRAIN (Inter regional train [Interregiozug]) - REGIONAL_TRAIN (Regional train [Regionalzug]) - CITY_TRAIN (City train [S-Bahn]) - SUBWAY (Subway [U-Bahn]) - TRAM (Tram [Strassenbahn]) - BUS (Bus [Bus]) - FERRY (Ferry [Faehre]) - FLIGHT (Flight [Flugzeug]) - CAR (Car [Auto]) - TAXI (Taxi) - SHUTTLE (Shuttle [Ruftaxi]) - BIKE ((E-)Bike [Fahrrad]) - SCOOTER ((E-)Scooter [Roller]) - WALK (Walk ([Laufen]) - UNKNOWN (Unknown)
 * @export
 * @enum {string}
 */

export const TransportType = {
  HighSpeedTrain: 'HIGH_SPEED_TRAIN',
  IntercityTrain: 'INTERCITY_TRAIN',
  InterRegionalTrain: 'INTER_REGIONAL_TRAIN',
  RegionalTrain: 'REGIONAL_TRAIN',
  CityTrain: 'CITY_TRAIN',
  Subway: 'SUBWAY',
  Tram: 'TRAM',
  Bus: 'BUS',
  Ferry: 'FERRY',
  Flight: 'FLIGHT',
  Car: 'CAR',
  Taxi: 'TAXI',
  Shuttle: 'SHUTTLE',
  Bike: 'BIKE',
  Scooter: 'SCOOTER',
  Walk: 'WALK',
  Unknown: 'UNKNOWN',
} as const;

export type TransportType = typeof TransportType[keyof typeof TransportType];

/**
 * JourneysApi - axios parameter creator
 * @export
 */
export const JourneysApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Finds journeys [Fahrten] by provided relation criterias [Fahrtrelation] (max of 100 matches are returned).
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} [date] date (yyyy-MM-dd) of scheduled start of journey [Verkehrstag], if omitted defaults to today (max of 7 days in the past is allowed)
     * @param {string} [administrationID] administration [Verwaltung] id
     * @param {string} [originEvaNumber] scheduled origin station [Geplanter Starthalt]
     * @param {string} [destinationEvaNumber] scheduled destination station [Geplanter Zielhalt]
     * @param {Array<TransportType>} [transports] transport types that should be returned, if ommitted all types of transport are returned
     * @param {string} [category] category of transport [Fahrtgattung]
     * @param {string} [line] line of transport [Linie]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    find: async (
      number: number,
      date?: string,
      administrationID?: string,
      originEvaNumber?: string,
      destinationEvaNumber?: string,
      transports?: Array<TransportType>,
      category?: string,
      line?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'number' is not null or undefined
      assertParamExists('find', 'number', number);
      const localVarPath = `/byrelation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substr(0, 10)
            : date;
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (administrationID !== undefined) {
        localVarQueryParameter['administrationID'] = administrationID;
      }

      if (originEvaNumber !== undefined) {
        localVarQueryParameter['originEvaNumber'] = originEvaNumber;
      }

      if (destinationEvaNumber !== undefined) {
        localVarQueryParameter['destinationEvaNumber'] = destinationEvaNumber;
      }

      if (transports) {
        localVarQueryParameter['transports'] = transports;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (line !== undefined) {
        localVarQueryParameter['line'] = line;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Finds journey [Fahrt] departure [Abfahrt] by provided relation criterias [Fahrtrelation]. Take care that at least a journey number or a line must be provided.
     * @param {string} date start date (yyyy-MM-dd) of of journey [Verkehrstag]
     * @param {string} evaNumber scheduled departure station id [Haltestelle ID] for desired departure
     * @param {string} timeSchedule scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {number} [number] number of transport [Fahrtnummer] at desired departure (at least a number or line must be provided)
     * @param {string} [line] line of transport [Linie] at desired departure (at least a number or line must be provided)
     * @param {string} [administrationID] administration [Verwaltung] id at desired departure
     * @param {string} [category] category of transport [Fahrtgattung] at desired departure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDeparture: async (
      date: string,
      evaNumber: string,
      timeSchedule: string,
      number?: number,
      line?: string,
      administrationID?: string,
      category?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists('findDeparture', 'date', date);
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('findDeparture', 'evaNumber', evaNumber);
      // verify required parameter 'timeSchedule' is not null or undefined
      assertParamExists('findDeparture', 'timeSchedule', timeSchedule);
      const localVarPath = `/departures/byrelation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substr(0, 10)
            : date;
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (line !== undefined) {
        localVarQueryParameter['line'] = line;
      }

      if (administrationID !== undefined) {
        localVarQueryParameter['administrationID'] = administrationID;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (evaNumber !== undefined) {
        localVarQueryParameter['evaNumber'] = evaNumber;
      }

      if (timeSchedule !== undefined) {
        localVarQueryParameter['timeSchedule'] =
          (timeSchedule as any) instanceof Date
            ? (timeSchedule as any).toISOString()
            : timeSchedule;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Event based [Fahrtereignisbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    journeyEventbasedById: async (
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'journeyID' is not null or undefined
      assertParamExists('journeyEventbasedById', 'journeyID', journeyID);
      const localVarPath = `/eventbased/{journeyID}`.replace(
        `{${'journeyID'}}`,
        encodeURIComponent(String(journeyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeCanceled !== undefined) {
        localVarQueryParameter['includeCanceled'] = includeCanceled;
      }

      if (includeJourneyReferences !== undefined) {
        localVarQueryParameter['includeJourneyReferences'] =
          includeJourneyReferences;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Segment based [Fahrtabschnittsbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    journeySegmentbasedById: async (
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'journeyID' is not null or undefined
      assertParamExists('journeySegmentbasedById', 'journeyID', journeyID);
      const localVarPath = `/segmentbased/{journeyID}`.replace(
        `{${'journeyID'}}`,
        encodeURIComponent(String(journeyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeCanceled !== undefined) {
        localVarQueryParameter['includeCanceled'] = includeCanceled;
      }

      if (includeJourneyReferences !== undefined) {
        localVarQueryParameter['includeJourneyReferences'] =
          includeJourneyReferences;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * JourneysApi - functional programming interface
 * @export
 */
export const JourneysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = JourneysApiAxiosParamCreator(configuration);
  return {
    /**
     * Finds journeys [Fahrten] by provided relation criterias [Fahrtrelation] (max of 100 matches are returned).
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} [date] date (yyyy-MM-dd) of scheduled start of journey [Verkehrstag], if omitted defaults to today (max of 7 days in the past is allowed)
     * @param {string} [administrationID] administration [Verwaltung] id
     * @param {string} [originEvaNumber] scheduled origin station [Geplanter Starthalt]
     * @param {string} [destinationEvaNumber] scheduled destination station [Geplanter Zielhalt]
     * @param {Array<TransportType>} [transports] transport types that should be returned, if ommitted all types of transport are returned
     * @param {string} [category] category of transport [Fahrtgattung]
     * @param {string} [line] line of transport [Linie]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async find(
      number: number,
      date?: string,
      administrationID?: string,
      originEvaNumber?: string,
      destinationEvaNumber?: string,
      transports?: Array<TransportType>,
      category?: string,
      line?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JourneyMatches>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.find(
        number,
        date,
        administrationID,
        originEvaNumber,
        destinationEvaNumber,
        transports,
        category,
        line,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Finds journey [Fahrt] departure [Abfahrt] by provided relation criterias [Fahrtrelation]. Take care that at least a journey number or a line must be provided.
     * @param {string} date start date (yyyy-MM-dd) of of journey [Verkehrstag]
     * @param {string} evaNumber scheduled departure station id [Haltestelle ID] for desired departure
     * @param {string} timeSchedule scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {number} [number] number of transport [Fahrtnummer] at desired departure (at least a number or line must be provided)
     * @param {string} [line] line of transport [Linie] at desired departure (at least a number or line must be provided)
     * @param {string} [administrationID] administration [Verwaltung] id at desired departure
     * @param {string} [category] category of transport [Fahrtgattung] at desired departure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDeparture(
      date: string,
      evaNumber: string,
      timeSchedule: string,
      number?: number,
      line?: string,
      administrationID?: string,
      category?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DepartureMatches>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findDeparture(
        date,
        evaNumber,
        timeSchedule,
        number,
        line,
        administrationID,
        category,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Event based [Fahrtereignisbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async journeyEventbasedById(
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JourneyEventBased>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.journeyEventbasedById(
          journeyID,
          includeCanceled,
          includeJourneyReferences,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Segment based [Fahrtabschnittsbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async journeySegmentbasedById(
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JourneySegmentBased>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.journeySegmentbasedById(
          journeyID,
          includeCanceled,
          includeJourneyReferences,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * JourneysApi - factory interface
 * @export
 */
export const JourneysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = JourneysApiFp(configuration);
  return {
    /**
     * Finds journeys [Fahrten] by provided relation criterias [Fahrtrelation] (max of 100 matches are returned).
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} [date] date (yyyy-MM-dd) of scheduled start of journey [Verkehrstag], if omitted defaults to today (max of 7 days in the past is allowed)
     * @param {string} [administrationID] administration [Verwaltung] id
     * @param {string} [originEvaNumber] scheduled origin station [Geplanter Starthalt]
     * @param {string} [destinationEvaNumber] scheduled destination station [Geplanter Zielhalt]
     * @param {Array<TransportType>} [transports] transport types that should be returned, if ommitted all types of transport are returned
     * @param {string} [category] category of transport [Fahrtgattung]
     * @param {string} [line] line of transport [Linie]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    find(
      number: number,
      date?: string,
      administrationID?: string,
      originEvaNumber?: string,
      destinationEvaNumber?: string,
      transports?: Array<TransportType>,
      category?: string,
      line?: string,
      options?: any,
    ): AxiosPromise<JourneyMatches> {
      return localVarFp
        .find(
          number,
          date,
          administrationID,
          originEvaNumber,
          destinationEvaNumber,
          transports,
          category,
          line,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Finds journey [Fahrt] departure [Abfahrt] by provided relation criterias [Fahrtrelation]. Take care that at least a journey number or a line must be provided.
     * @param {string} date start date (yyyy-MM-dd) of of journey [Verkehrstag]
     * @param {string} evaNumber scheduled departure station id [Haltestelle ID] for desired departure
     * @param {string} timeSchedule scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {number} [number] number of transport [Fahrtnummer] at desired departure (at least a number or line must be provided)
     * @param {string} [line] line of transport [Linie] at desired departure (at least a number or line must be provided)
     * @param {string} [administrationID] administration [Verwaltung] id at desired departure
     * @param {string} [category] category of transport [Fahrtgattung] at desired departure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDeparture(
      date: string,
      evaNumber: string,
      timeSchedule: string,
      number?: number,
      line?: string,
      administrationID?: string,
      category?: string,
      options?: any,
    ): AxiosPromise<DepartureMatches> {
      return localVarFp
        .findDeparture(
          date,
          evaNumber,
          timeSchedule,
          number,
          line,
          administrationID,
          category,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Event based [Fahrtereignisbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    journeyEventbasedById(
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options?: any,
    ): AxiosPromise<JourneyEventBased> {
      return localVarFp
        .journeyEventbasedById(
          journeyID,
          includeCanceled,
          includeJourneyReferences,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Segment based [Fahrtabschnittsbasiert] view.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {boolean} [includeCanceled] include canceled arrivals / departures
     * @param {boolean} [includeJourneyReferences] include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    journeySegmentbasedById(
      journeyID: string,
      includeCanceled?: boolean,
      includeJourneyReferences?: boolean,
      options?: any,
    ): AxiosPromise<JourneySegmentBased> {
      return localVarFp
        .journeySegmentbasedById(
          journeyID,
          includeCanceled,
          includeJourneyReferences,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for find operation in JourneysApi.
 * @export
 * @interface JourneysApiFindRequest
 */
export interface JourneysApiFindRequest {
  /**
   * number of transport [Fahrtnummer]
   * @type {number}
   * @memberof JourneysApiFind
   */
  readonly number: number;

  /**
   * date (yyyy-MM-dd) of scheduled start of journey [Verkehrstag], if omitted defaults to today (max of 7 days in the past is allowed)
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly date?: string;

  /**
   * administration [Verwaltung] id
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly administrationID?: string;

  /**
   * scheduled origin station [Geplanter Starthalt]
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly originEvaNumber?: string;

  /**
   * scheduled destination station [Geplanter Zielhalt]
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly destinationEvaNumber?: string;

  /**
   * transport types that should be returned, if ommitted all types of transport are returned
   * @type {Array<TransportType>}
   * @memberof JourneysApiFind
   */
  readonly transports?: Array<TransportType>;

  /**
   * category of transport [Fahrtgattung]
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly category?: string;

  /**
   * line of transport [Linie]
   * @type {string}
   * @memberof JourneysApiFind
   */
  readonly line?: string;
}

/**
 * Request parameters for findDeparture operation in JourneysApi.
 * @export
 * @interface JourneysApiFindDepartureRequest
 */
export interface JourneysApiFindDepartureRequest {
  /**
   * start date (yyyy-MM-dd) of of journey [Verkehrstag]
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly date: string;

  /**
   * scheduled departure station id [Haltestelle ID] for desired departure
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly evaNumber: string;

  /**
   * scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly timeSchedule: string;

  /**
   * number of transport [Fahrtnummer] at desired departure (at least a number or line must be provided)
   * @type {number}
   * @memberof JourneysApiFindDeparture
   */
  readonly number?: number;

  /**
   * line of transport [Linie] at desired departure (at least a number or line must be provided)
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly line?: string;

  /**
   * administration [Verwaltung] id at desired departure
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly administrationID?: string;

  /**
   * category of transport [Fahrtgattung] at desired departure
   * @type {string}
   * @memberof JourneysApiFindDeparture
   */
  readonly category?: string;
}

/**
 * Request parameters for journeyEventbasedById operation in JourneysApi.
 * @export
 * @interface JourneysApiJourneyEventbasedByIdRequest
 */
export interface JourneysApiJourneyEventbasedByIdRequest {
  /**
   * id of journey [FahrtID]
   * @type {string}
   * @memberof JourneysApiJourneyEventbasedById
   */
  readonly journeyID: string;

  /**
   * include canceled arrivals / departures
   * @type {boolean}
   * @memberof JourneysApiJourneyEventbasedById
   */
  readonly includeCanceled?: boolean;

  /**
   * include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
   * @type {boolean}
   * @memberof JourneysApiJourneyEventbasedById
   */
  readonly includeJourneyReferences?: boolean;
}

/**
 * Request parameters for journeySegmentbasedById operation in JourneysApi.
 * @export
 * @interface JourneysApiJourneySegmentbasedByIdRequest
 */
export interface JourneysApiJourneySegmentbasedByIdRequest {
  /**
   * id of journey [FahrtID]
   * @type {string}
   * @memberof JourneysApiJourneySegmentbasedById
   */
  readonly journeyID: string;

  /**
   * include canceled arrivals / departures
   * @type {boolean}
   * @memberof JourneysApiJourneySegmentbasedById
   */
  readonly includeCanceled?: boolean;

  /**
   * include journey references like relief [Entlastung], replace [Ersatz], continuation [Durchbindung], travelswith [Vereinigung / Fluegelung]
   * @type {boolean}
   * @memberof JourneysApiJourneySegmentbasedById
   */
  readonly includeJourneyReferences?: boolean;
}

/**
 * JourneysApi - object-oriented interface
 * @export
 * @class JourneysApi
 * @extends {BaseAPI}
 */
export class JourneysApi extends BaseAPI {
  /**
   * Finds journeys [Fahrten] by provided relation criterias [Fahrtrelation] (max of 100 matches are returned).
   * @param {JourneysApiFindRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JourneysApi
   */
  public find(
    requestParameters: JourneysApiFindRequest,
    options?: AxiosRequestConfig,
  ) {
    return JourneysApiFp(this.configuration)
      .find(
        requestParameters.number,
        requestParameters.date,
        requestParameters.administrationID,
        requestParameters.originEvaNumber,
        requestParameters.destinationEvaNumber,
        requestParameters.transports,
        requestParameters.category,
        requestParameters.line,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Finds journey [Fahrt] departure [Abfahrt] by provided relation criterias [Fahrtrelation]. Take care that at least a journey number or a line must be provided.
   * @param {JourneysApiFindDepartureRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JourneysApi
   */
  public findDeparture(
    requestParameters: JourneysApiFindDepartureRequest,
    options?: AxiosRequestConfig,
  ) {
    return JourneysApiFp(this.configuration)
      .findDeparture(
        requestParameters.date,
        requestParameters.evaNumber,
        requestParameters.timeSchedule,
        requestParameters.number,
        requestParameters.line,
        requestParameters.administrationID,
        requestParameters.category,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Event based [Fahrtereignisbasiert] view.
   * @param {JourneysApiJourneyEventbasedByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JourneysApi
   */
  public journeyEventbasedById(
    requestParameters: JourneysApiJourneyEventbasedByIdRequest,
    options?: AxiosRequestConfig,
  ) {
    return JourneysApiFp(this.configuration)
      .journeyEventbasedById(
        requestParameters.journeyID,
        requestParameters.includeCanceled,
        requestParameters.includeJourneyReferences,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a journey [Fahrtverlauf] with all its segments [Fahrtabschnitte], arrivals [Ankuenfte] and departures [Abfahrten] for the requested id. Segment based [Fahrtabschnittsbasiert] view.
   * @param {JourneysApiJourneySegmentbasedByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JourneysApi
   */
  public journeySegmentbasedById(
    requestParameters: JourneysApiJourneySegmentbasedByIdRequest,
    options?: AxiosRequestConfig,
  ) {
    return JourneysApiFp(this.configuration)
      .journeySegmentbasedById(
        requestParameters.journeyID,
        requestParameters.includeCanceled,
        requestParameters.includeJourneyReferences,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
