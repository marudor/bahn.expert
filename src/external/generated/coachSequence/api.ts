/* tslint:disable */
/* eslint-disable */
/**
 * RIS::Transports
 * ## Info  * member of the **[RIS-API](https://db-planet.deutschebahn.com/pages/reisendeninformation-ris-api)** family * powered by [DB Systel BusinessHub - doServices](https://user-portal.hub.ose.db.de/) * powered by [T.R Reisendeninformation](https://db-planet.deutschebahn.com/pages/reisendeninformation/apps/content/willkommen)  ## Capabilities  ### Vehicle-Sequences Returns the vehicle-sequence [Wagenreihung] for a departure [Abfahrt] or an arrival [Ankunft] within a journey [Fahrt], meaning:  * the vehicle groups that travel together [Vereinigung], their names and destinations * the sequence of the vehicles and the vehicle type (control car, dining car, passenger car etc.) * the position of the vehicles at the platform / track / sector [Plattform / Gleis / Sektor] and according platform information * existing equipment features [Ausstattungsmerkmale] (boarding aid, toilet, etc.) * flag that indicates whether sequence matches schedule [Bitte beachten Sie die geänderte Wagenreihung]  Additionally, all administration IDs [Verwaltungs ID / Code] the system is able to provide vehicle-sequences for can be queried.  ### Occupancies Provides occupancy information [Auslastungsinformation] for a journey [Fahrt] and its departures [Abfahrten], if available. This information can therefore be used to:  * let the travellers know the occupancy of a particular journey [Fahrt] at a particular departure [Abfahrt] * let the travellers know where to stand at the platform in order to board the train at the emptiest vehicle [Fahrgastlenkung beim Einstieg]  ### Vehicles by vehicle-id  Returns all journeys [Fahrten] a vehicle [Fahrzeug] with a particular vehicle-id [usually the UIC-number] travels in for a specific date:  * enables consumers to find the journey a traveller is currently travelling with by the uic-number of a vehicle * can be used to match a particular train to its journey [Zugtaufe]  ### Asynchronous change-notifications  The RIS-API event-system [RIS::Events](https://db-planet.deutschebahn.com/pages/reisendeninformation-ris-api/apps/content/events) can be used to get push-notifications in case information within RIS::Transports changes. This enables use-cases like:  * refreshing ui in case information changes * doing something in your backend in case information changes\\n* caching information and invalidate cache in case information changes  ## Limitations / Known Issues  * vehicle-sequences are limited to 22h ahead and are usually ready at about ~22:30 o\'clock for the next day\\n* vehicle-amenity status is only working for bike spaces for DB Regio Baden-Württemberg, all other amenities don\'t have a status at all * vehicle-sequences by-arrival are currently implemented as a workaround due to lack of information from the source system * the field `vehicleGroupName` sometimes can contain a string with two vehicle group names splitted by a semicolon e.g RPF200009;RPF47041, instead of one vehicle group name  ## Getting Started  * get to know the vision behind [RIS-API](https://db.de/ris-api) * visit our [documentation](https://ris.gitpages.tech.rz.db.de/risapi/documentation/), learn how to [get started with openapi](https://ris.gitpages.tech.rz.db.de/risapi/documentation/05_Coding-Dojo/020_getting_started_openapi.html) or how to [get started with asyncapi](https://ris.gitpages.tech.rz.db.de/risapi/documentation/05_Coding-Dojo/030_getting_started_asyncapi.html) and check out our [coding-examples](https://ris.gitpages.tech.rz.db.de/risapi/documentation/05_Coding-Dojo/040_examples.html) * bounty hunter, bug finder or just idea creator, we are thirsty to hear from you - get in touch with us by sending us an [email](mailto:doServices.Sirius.Team@deutschebahn.com)  ## Swagger-UI  This specification is also viewable with Swagger-UI [here](https://do-services-sirius.gitpages.tech.rz.db.de/ris-transports/api/). Keep in mind, the feature \"Try it out\" isn\'t working on Swagger-UI, since some gateway features are missing.
 *
 * The version of the OpenAPI document: 2.6.1.10
 * Contact: doServices.Sirius.Team@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Information on the operator [Betreiber] and the administration [Verwaltung] of the journey.
 * @export
 * @interface Administration
 */
export interface Administration {
  /**
   * Unique id of the administration [Verwaltung].
   * @type {string}
   * @memberof Administration
   */
  administrationID: string;
  /**
   * Unique code of the operator [Betreiber].
   * @type {string}
   * @memberof Administration
   */
  operatorCode: string;
  /**
   * Name of the operator [Betreiber].
   * @type {string}
   * @memberof Administration
   */
  operatorName: string;
}
/**
 * Status an amenity [Ausstattungsmerkmal] can have. - AVAILABLE (Amenity is considered as available [Verfügbar]) - NOT_AVAILABLE (Amenity is considered as not available [Nicht Verfügbar]) - RESERVED (Amenity is considered as reserved [Reserviert]) - UNDEFINED (Status is undefined [Undefiniert])
 * @export
 * @enum {string}
 */

export const AmenityStatus = {
  Available: 'AVAILABLE',
  NotAvailable: 'NOT_AVAILABLE',
  Reserved: 'RESERVED',
  Undefined: 'UNDEFINED',
} as const;

export type AmenityStatus = (typeof AmenityStatus)[keyof typeof AmenityStatus];

/**
 * Type of amenity [Ausstattungsmerkmal] mostly according to VDV 454. - BISTRO (Bordbistro) - AIR_CONDITION (Klimaanlage) - BIKE_SPACE (Fahrradstellplätze) - WHEELCHAIR_SPACE (Rollstuhlstellplätze) - TOILET_WHEELCHAIR (Rollstuhlgängige Toilette) - ZONE_MULTI_PURPOSE (Mehrzweckbereich) - BOARDING_AID (Einstiegshilfe) - CABIN_INFANT (Kleinkindabteil) - ZONE_QUIET (Ruhebereich) - ZONE_FAMILY (Familienbereich) - INFO (Info-Abteil) - SEATS_SEVERELY_DISABLED (Plätze für Schwerbehinderte) - SEATS_BAHN_COMFORT (Plätze für BahnComfort-Kunden) - SEATS_LUFTHANSA_EXPRESS_RAIL (Plätze für LH-Codeshare) ??? - WIFI (WLAN-Hotspot)
 * @export
 * @enum {string}
 */

export const AmenityType = {
  Bistro: 'BISTRO',
  AirCondition: 'AIR_CONDITION',
  BikeSpace: 'BIKE_SPACE',
  WheelchairSpace: 'WHEELCHAIR_SPACE',
  ToiletWheelchair: 'TOILET_WHEELCHAIR',
  ZoneMultiPurpose: 'ZONE_MULTI_PURPOSE',
  BoardingAid: 'BOARDING_AID',
  CabinInfant: 'CABIN_INFANT',
  ZoneQuiet: 'ZONE_QUIET',
  ZoneFamily: 'ZONE_FAMILY',
  Info: 'INFO',
  SeatsSeverelyDisabled: 'SEATS_SEVERELY_DISABLED',
  SeatsBahnComfort: 'SEATS_BAHN_COMFORT',
  SeatsLufthansaExpressRail: 'SEATS_LUFTHANSA_EXPRESS_RAIL',
  Wifi: 'WIFI',
} as const;

export type AmenityType = (typeof AmenityType)[keyof typeof AmenityType];

/**
 * Unique identification of a departure [Abfahrt] within a particular journey [Fahrt] by its relation [Abfahrt-Relation].
 * @export
 * @interface DepartureRelation
 */
export interface DepartureRelation {
  /**
   * Eva number of departure stop-place [Haltestelle] within journey.
   * @type {string}
   * @memberof DepartureRelation
   */
  evaNumber: string;
  /**
   * Scheduled departure time [Geplante Abfahrtzeit] at stop-place [Haltestelle] within journey as fully-qualified-date (ISO-8601 with time-zone or offset).
   * @type {string}
   * @memberof DepartureRelation
   */
  timeSchedule: string;
}
/**
 * Optional direction information [Richtungstext] for a particular transport that may differ from the destination [Zielhalt] on some parts of the journey.
 * @export
 * @interface DirectionInfo
 */
export interface DirectionInfo {
  /**
   * Direction text [Richtungstext]. Must not necessarly be the name of a real stop-place [Haltestelle] (for instance \'Richtung Automobilmesse\'). For instance before the stop \'fare\' the transport has direction \'fare\', after \'fare\' has been reached maybe \'central station\' or \'airport\'.
   * @type {string}
   * @memberof DirectionInfo
   */
  text: string;
  /**
   * Optional list of stop-places [Haltestellen] the direction text refers to. May be more than one stop-place for cases like for instance \'Richtung Messe & Hauptbahnhof\'.
   * @type {Array<string>}
   * @memberof DirectionInfo
   */
  stopPlaces: Array<string>;
}
/**
 * Detailed error information on field level.
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorDetail
   */
  errorCode?: number;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorDetail
   */
  title: string;
  /**
   * Name of field / element that raised the error.
   * @type {string}
   * @memberof ErrorDetail
   */
  field: string;
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorDetail
   */
  detail: string;
}
/**
 * API error object conforming to RFC7807.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorResponse
   */
  errorCode?: number;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorResponse
   */
  title: string;
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorResponse
   */
  detail: string;
  /**
   * Http status for error origin.
   * @type {number}
   * @memberof ErrorResponse
   */
  status?: number;
  /**
   * Unique identifier for instance that raised the error.
   * @type {string}
   * @memberof ErrorResponse
   */
  instanceId?: string;
  /**
   * List of detailed errors in case multiple errors have lead to the surrounding error.
   * @type {Array<ErrorDetail>}
   * @memberof ErrorResponse
   */
  errors?: Array<ErrorDetail>;
}
/**
 * Occupancy [Auslastung] information for a journeys departure [Abfahrt].
 * @export
 * @interface JourneyDepartureOccupancy
 */
export interface JourneyDepartureOccupancy {
  /**
   * ID of departure [Abfahrt-ID].
   * @type {string}
   * @memberof JourneyDepartureOccupancy
   */
  departureID: string;
  /**
   *
   * @type {Occupancy}
   * @memberof JourneyDepartureOccupancy
   */
  occupancy: Occupancy;
}
/**
 * Occupancy [Auslastung] information for a journeys departure [Abfahrt]. Unmatched version.
 * @export
 * @interface JourneyDepartureOccupancyUnmatched
 */
export interface JourneyDepartureOccupancyUnmatched {
  /**
   *
   * @type {DepartureRelation}
   * @memberof JourneyDepartureOccupancyUnmatched
   */
  departureRelation: DepartureRelation;
  /**
   *
   * @type {Occupancy}
   * @memberof JourneyDepartureOccupancyUnmatched
   */
  occupancy: Occupancy;
}
/**
 * Occupancy [Auslastung] information for a journey [Fahrt] and its departures [Abfahrten].
 * @export
 * @interface JourneyOccupancy
 */
export interface JourneyOccupancy {
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof JourneyOccupancy
   */
  journeyID: string;
  /**
   * List of occupancy information for journey departures [Abfahrten]. Please note that some departures may be missing in case no occupancy information is available.
   * @type {Array<JourneyDepartureOccupancy>}
   * @memberof JourneyOccupancy
   */
  departures?: Array<JourneyDepartureOccupancy>;
}
/**
 * Occupancy [Auslastung] information for a journey [Fahrt] and its departures [Abfahrten]. Unmatched version.
 * @export
 * @interface JourneyOccupancyUnmatched
 */
export interface JourneyOccupancyUnmatched {
  /**
   *
   * @type {JourneyRelationWithoutHead}
   * @memberof JourneyOccupancyUnmatched
   */
  journeyRelation: JourneyRelationWithoutHead;
  /**
   * List of occupancy information for journey departures [Abfahrten]. Please note that some departures may be missing in case no occupancy information is available.
   * @type {Array<JourneyDepartureOccupancyUnmatched>}
   * @memberof JourneyOccupancyUnmatched
   */
  departures?: Array<JourneyDepartureOccupancyUnmatched>;
}
/**
 * Description of a journey [Fahrt] by key attributes, that are summarized as journey relation [Fahrtrelation].
 * @export
 * @interface JourneyRelation
 */
export interface JourneyRelation {
  /**
   * Scheduled start time [Geplante Startzeit] at scheduled start stop-place [Geplanter Starthalt] as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof JourneyRelation
   */
  startTime: string;
  /**
   * Eva number of scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelation
   */
  startEvaNumber: string;
  /**
   * Unique id of the administration [Verwaltung] at scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelation
   */
  startAdministrationID?: string;
  /**
   * Category [externe Fahrtgattung nach Ausgabensteurerung] at scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelation
   */
  startCategory: string;
  /**
   * Number of journey [Fahrtnummer] at scheduled start stop-place [Geplanter Starthalt].
   * @type {number}
   * @memberof JourneyRelation
   */
  startNumber: number;
}
/**
 * Description of a journey [Fahrt] by key attributes, that are summarized as journey relation [Fahrtrelation] without header information.
 * @export
 * @interface JourneyRelationWithoutHead
 */
export interface JourneyRelationWithoutHead {
  /**
   * Scheduled start time [Geplante Startzeit] at scheduled start stop-place [Geplanter Starthalt] as fully-qualified-date (ISO-8601 with time-zone or offset).
   * @type {string}
   * @memberof JourneyRelationWithoutHead
   */
  startTime: string;
  /**
   * Eva number of scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelationWithoutHead
   */
  startEvaNumber: string;
  /**
   * Unique id of the administration [Verwaltung] at scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelationWithoutHead
   */
  startAdministrationID: string;
  /**
   * Category [externe Fahrtgattung nach Ausgabensteurerung] at scheduled start stop-place [Geplanter Starthalt].
   * @type {string}
   * @memberof JourneyRelationWithoutHead
   */
  startCategory: string;
  /**
   * Number of journey [Fahrtnummer] at scheduled start stop-place [Geplanter Starthalt].
   * @type {number}
   * @memberof JourneyRelationWithoutHead
   */
  startNumber: number;
}
/**
 * Occupancy level [Auslastungsstufe] of a particular journey [Fahrt] departure [Abfahrt]. Occupancy may refer to the whole vehicle sequence [Formation], a vehicle group [Fahrzeuggruppe], a single vehicle [Fahrzeug] or to specific parts of those entities.
 * @export
 * @interface Occupancy
 */
export interface Occupancy {
  /**
   *
   * @type {OccupancyLevel}
   * @memberof Occupancy
   */
  levelFirstClass?: OccupancyLevel;
  /**
   *
   * @type {OccupancyLevel}
   * @memberof Occupancy
   */
  levelEconomyClass?: OccupancyLevel;
}

/**
 * Detail level for vehicle occupancy [Auslastung] information. - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
 * @export
 * @enum {string}
 */

export const OccupancyDetail = {
  None: 'NONE',
  Overall: 'OVERALL',
  Detail: 'DETAIL',
} as const;

export type OccupancyDetail =
  (typeof OccupancyDetail)[keyof typeof OccupancyDetail];

/**
 * Occupancy [Auslastung] level a journey [Fahrt], departure [Abfahrt], vehicle group [Fahrzeuggruppe] or vehicle [Fahrzeug] may have. - HIGH (occupancy is considered as high) - MIDDLE (occupancy is considered as middle) - LOW (occupancy is considered as low) - UNDEFINED (occupancy is unknown / undefined)
 * @export
 * @enum {string}
 */

export const OccupancyLevel = {
  High: 'HIGH',
  Middle: 'MIDDLE',
  Low: 'LOW',
  Undefined: 'UNDEFINED',
} as const;

export type OccupancyLevel =
  (typeof OccupancyLevel)[keyof typeof OccupancyLevel];

/**
 * Platform [Gleis, Bahnsteig, Plattform] information for vehicle-sequences [Wagenreihungsinformationen]. All ranges and positions of objects are given in meter in local coordinates, e.g. as a distance to a fixed point somewhere on the platform and differentiating between the two possible directions by a plus- and a minus-sign.
 * @export
 * @interface Platform
 */
export interface Platform {
  /**
   * Name of the platform (12, 1a, Nord, Süd etc.).
   * @type {string}
   * @memberof Platform
   */
  name: string;
  /**
   * Start of the usable part of the platform given in meter in local coordinates. This value may differ from zero and may be positive as well as negative.
   * @type {number}
   * @memberof Platform
   */
  start?: number;
  /**
   * End of the usable part of the platform given in meter in local coordinates.
   * @type {number}
   * @memberof Platform
   */
  end?: number;
  /**
   * List of sectors [Sektoren] that belong to the platform.
   * @type {Array<Sector>}
   * @memberof Platform
   */
  sectors?: Array<Sector>;
}
/**
 * Optional replacement transport [Ersatzverkehr] information, in case transport is a rail replacement transport [Schienenersatzverkehr (SEV)] or emergency bus service [Busnotverkehr]. Indicates that this transport is a replacement transport.
 * @export
 * @interface ReplacementTransport
 */
export interface ReplacementTransport {
  /**
   * Real type of replacement transport that may differ from sales perspective (for instance a \'REGIONAL_TRAIN\' is usuallay replaced by a \'BUS\'). Possible values are: - HIGH_SPEED_TRAIN (High speed train [Hochgeschwindigkeitszug] like ICE or TGV etc.) - INTERCITY_TRAIN (Inter city train [Intercityzug]) - INTER_REGIONAL_TRAIN (Inter regional train [Interregiozug]) - REGIONAL_TRAIN (Regional train [Regionalzug]) - CITY_TRAIN (City train [S-Bahn]) - SUBWAY (Subway [U-Bahn]) - TRAM (Tram [Strassenbahn]) - BUS (Bus [Bus]) - FERRY (Ferry [Faehre]) - FLIGHT (Flight [Flugzeug]) - CAR (Car [Auto]) - TAXI (Taxi) - SHUTTLE (Shuttle [Ruftaxi]) - BIKE ((E-)Bike [Fahrrad]) - SCOOTER ((E-)Scooter [Roller]) - WALK (Walk ([Laufen]) - UNKNOWN (Unknown)
   * @type {string}
   * @memberof ReplacementTransport
   */
  realType: string;
}
/**
 * Platform [Gleis, Bahnsteig, Plattform] sector [Gleisabschnitt, Steigabschnitt] information for vehicle-sequences [Wagenreihungsinformationen].
 * @export
 * @interface Sector
 */
export interface Sector {
  /**
   * Name of the sector [Sektor / Mast etc.].
   * @type {string}
   * @memberof Sector
   */
  name: string;
  /**
   * Start of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  start: number;
  /**
   * End of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  end: number;
}
/**
 * Stop at a particular stop-place [Haltestelle] for arrival / departure boards.
 * @export
 * @interface StopAtStopPlace
 */
export interface StopAtStopPlace {
  /**
   * Eva number of stop-place.
   * @type {string}
   * @memberof StopAtStopPlace
   */
  evaNumber: string;
  /**
   * Name for stop-place in fixed language (usually DE).
   * @type {string}
   * @memberof StopAtStopPlace
   */
  name: string;
  /**
   * Indicates whether the stop ie departure / arrival has been canceled [Haltausfall].
   * @type {boolean}
   * @memberof StopAtStopPlace
   */
  canceled: boolean;
}
/**
 * Public transport [Öffentlicher Verkehr] and vehicle [Fahrzeug] matching result for a particular vehicle id.
 * @export
 * @interface TransportMatchVehicleID
 */
export interface TransportMatchVehicleID {
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportMatchVehicleID
   */
  journeyID: string;
  /**
   *
   * @type {JourneyRelation}
   * @memberof TransportMatchVehicleID
   */
  journeyRelation: JourneyRelation;
  /**
   *
   * @type {TransportPublic}
   * @memberof TransportMatchVehicleID
   */
  transport?: TransportPublic;
  /**
   * Wagon identification number [Wagenordnungsnummer] of vehicle in transport.
   * @type {number}
   * @memberof TransportMatchVehicleID
   */
  wagonIdentificationNumber?: number;
  /**
   * Scheduled start time of journey, meaning the departure of the first stop ie the origin of the journey as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof TransportMatchVehicleID
   */
  scheduledStartTime?: string;
}
/**
 * Public transports [Öffentlicher Verkehr] and vehicles [Fahrzeug] matching results for a particular vehicle id.
 * @export
 * @interface TransportMatchVehicleIDs
 */
export interface TransportMatchVehicleIDs {
  /**
   *
   * @type {TransportMatchVehicleInGroup}
   * @memberof TransportMatchVehicleIDs
   */
  vehicle: TransportMatchVehicleInGroup;
  /**
   * List of matched transports.
   * @type {Array<TransportMatchVehicleID>}
   * @memberof TransportMatchVehicleIDs
   */
  transports: Array<TransportMatchVehicleID>;
}
/**
 * Public transport [Öffentlicher Verkehr] and vehicle [Fahrzeug] matching result for a particular vehicle.
 * @export
 * @interface TransportMatchVehicleInGroup
 */
export interface TransportMatchVehicleInGroup {
  /**
   * ID of the vehicle (for rail vehicles usually the UIC identification nunmber).
   * @type {string}
   * @memberof TransportMatchVehicleInGroup
   */
  vehicleID: string;
  /**
   *
   * @type {VehicleType}
   * @memberof TransportMatchVehicleInGroup
   */
  type: VehicleType;
  /**
   * Name of the vehicle group, if present.
   * @type {string}
   * @memberof TransportMatchVehicleInGroup
   */
  vehicleGroupName?: string;
}
/**
 * Public transport description for all types of trains, buses, subways, trams etc.
 * @export
 * @interface TransportPublic
 */
export interface TransportPublic {
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublic
   */
  type: TransportType;
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublic
   */
  category: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublic
   */
  number: number;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublic
   */
  line?: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublic
   */
  label?: string;
  /**
   *
   * @type {ReplacementTransport}
   * @memberof TransportPublic
   */
  replacementTransport?: ReplacementTransport;
  /**
   *
   * @type {DirectionInfo}
   * @memberof TransportPublic
   */
  direction?: DirectionInfo;
}

/**
 * Public transport [Oeffentlicher Transport] with (scheduled) destination [Ziel] and differing destination in case the final stop of the journey changed [Haltausfall, Laufwegverlängerung, ...].
 * @export
 * @interface TransportPublicDestination
 */
export interface TransportPublicDestination {
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublicDestination
   */
  type: TransportType;
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  category: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublicDestination
   */
  number: number;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  line?: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  label?: string;
  /**
   *
   * @type {ReplacementTransport}
   * @memberof TransportPublicDestination
   */
  replacementTransport?: ReplacementTransport;
  /**
   *
   * @type {DirectionInfo}
   * @memberof TransportPublicDestination
   */
  direction?: DirectionInfo;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportPublicDestination
   */
  journeyID: string;
  /**
   *
   * @type {StopAtStopPlace}
   * @memberof TransportPublicDestination
   */
  destination: StopAtStopPlace;
  /**
   *
   * @type {StopAtStopPlace}
   * @memberof TransportPublicDestination
   */
  differingDestination?: StopAtStopPlace;
}

/**
 * Public transport [Oeffentlicher Transport] with origin [Herkunft].
 * @export
 * @interface TransportPublicOrigin
 */
export interface TransportPublicOrigin {
  /**
   *
   * @type {TransportType}
   * @memberof TransportPublicOrigin
   */
  type: TransportType;
  /**
   * Code of the transport [Fahrtgattung].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  category: string;
  /**
   * Number of the transport [Fahrtnummer].
   * @type {number}
   * @memberof TransportPublicOrigin
   */
  number: number;
  /**
   * Line of the transport [Linie].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  line?: string;
  /**
   * Marketing - or product name of the transport, for instance \'Sprinter\' or \'Schwarzwaldexpress\' etc. [Marketing Name / Produkt Name].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  label?: string;
  /**
   *
   * @type {ReplacementTransport}
   * @memberof TransportPublicOrigin
   */
  replacementTransport?: ReplacementTransport;
  /**
   *
   * @type {DirectionInfo}
   * @memberof TransportPublicOrigin
   */
  direction?: DirectionInfo;
  /**
   * ID of journey [FahrtID].
   * @type {string}
   * @memberof TransportPublicOrigin
   */
  journeyID: string;
  /**
   *
   * @type {StopAtStopPlace}
   * @memberof TransportPublicOrigin
   */
  origin: StopAtStopPlace;
  /**
   *
   * @type {StopAtStopPlace}
   * @memberof TransportPublicOrigin
   */
  differingOrigin?: StopAtStopPlace;
}

/**
 * Type of transport. - HIGH_SPEED_TRAIN (High speed train [Hochgeschwindigkeitszug] like ICE or TGV etc.) - INTERCITY_TRAIN (Inter city train [Intercityzug]) - INTER_REGIONAL_TRAIN (Inter regional train [Interregiozug]) - REGIONAL_TRAIN (Regional train [Regionalzug]) - CITY_TRAIN (City train [S-Bahn]) - SUBWAY (Subway [U-Bahn]) - TRAM (Tram [Strassenbahn]) - BUS (Bus [Bus]) - FERRY (Ferry [Faehre]) - FLIGHT (Flight [Flugzeug]) - CAR (Car [Auto]) - TAXI (Taxi) - SHUTTLE (Shuttle [Ruftaxi]) - BIKE ((E-)Bike [Fahrrad]) - SCOOTER ((E-)Scooter [Roller]) - WALK (Walk ([Laufen]) - UNKNOWN (Unknown)
 * @export
 * @enum {string}
 */

export const TransportType = {
  HighSpeedTrain: 'HIGH_SPEED_TRAIN',
  IntercityTrain: 'INTERCITY_TRAIN',
  InterRegionalTrain: 'INTER_REGIONAL_TRAIN',
  RegionalTrain: 'REGIONAL_TRAIN',
  CityTrain: 'CITY_TRAIN',
  Subway: 'SUBWAY',
  Tram: 'TRAM',
  Bus: 'BUS',
  Ferry: 'FERRY',
  Flight: 'FLIGHT',
  Car: 'CAR',
  Taxi: 'TAXI',
  Shuttle: 'SHUTTLE',
  Bike: 'BIKE',
  Scooter: 'SCOOTER',
  Walk: 'WALK',
  Unknown: 'UNKNOWN',
} as const;

export type TransportType = (typeof TransportType)[keyof typeof TransportType];

/**
 * Vehicle amenity [Ausstattungsmerkmal].
 * @export
 * @interface VehicleAmenity
 */
export interface VehicleAmenity {
  /**
   *
   * @type {AmenityType}
   * @memberof VehicleAmenity
   */
  type: AmenityType;
  /**
   * Amount of amenity, may be empty.
   * @type {number}
   * @memberof VehicleAmenity
   */
  amount?: number;
  /**
   *
   * @type {AmenityStatus}
   * @memberof VehicleAmenity
   */
  status: AmenityStatus;
}

/**
 * Category of vehicle [Fahrzeug] according to basic visual differentiation. - DOUBLEDECK_FIRST_ECONOMY_CLASS (Doppelstockwagen 1.& 2. Klasse) - DOUBLEDECK_FIRST_CLASS (Doppelstockwagen 1. Klasse) - DOUBLEDECK_ECONOMY_CLASS (Doppelstockwagen 2. Klasse) - DOUBLEDECK_CONTROLCAR_FIRST_ECONOMOY_CLASS (Doppelstocksteuerwagen 1. & 2. Klasse) - DOUBLEDECK_CONTROLCAR_FIRST_CLASS (Doppelstocksteuerwagen 1. Klasse) - DOUBLEDECK_CONTROLCAR_ECONOMY_CLASS (Doppelstocksteuerwagen 2. Klasse) - DOUBLEDECK_CARCARRIER_PASSENGERTRAIN (Doppelstock-Autotransportwagen der Reisezugwagen-Bauart) - PASSENGERCARRIAGE_FIRST_ECONOMY_CLASS (Reisezugwagen 1.& 2. Klasse) - PASSENGERCARRIAGE_FIRST_CLASS (Reisezugwagen 1.Klasse) - PASSENGERCARRIAGE_ECONOMY_CLASS (Reisezugwagen 2.Klasse) - CONTROLCAR_FIRST_CLASS (Steuerwagen & 1.Klasse) - CONTROLCAR_ECONOMY_CLASS (Steuerwagen & 2.Klasse) - CONTROLCAR_FIRST_ECONOMY_CLASS (Steuerwagen 1.& 2.Klasse) - DOUBLECONTROLCAR_ECONOMY_CLASS (Beidseitiger Steuerwagen aka \'Schienenbus\' & 2.Klasse) - DOUBLECONTROLCAR_FIRST_ECONOMY_CLASS (Beidseitiger Steuerwagen aka \'Schienenbus\' 1.& 2.Klasse) - DININGCAR (Speisewagen) - HALFDININGCAR_FIRST_CLASS (Halbspeisewagen & 1. Klasse) - HALFDININGCAR_ECONOMY_CLASS (Halbspeisewagen & 2. Klasse) - SLEEPER_FIRST_CLASS (Schlafwagen 1. Klasse) - SLEEPER_FIRST_ECONOMY_CLASS (Schlafwagen 1. & 2. Klasse) - SLEEPER_ECONOMY_CLASS (Schlafwagen 2. Klasse) - COUCHETTE_FIRST_CLASS (Liegewagen 1. Klasse) - COUCHETTE_ECONOMY_CLASS (Liegewagen 2. Klasse) - BAGGAGECAR (Gepaeckwagen) - LOCOMOTIVE (Lok) - POWERCAR (Triebkopf) - UNDEFINED (unbekannt)
 * @export
 * @enum {string}
 */

export const VehicleCategory = {
  DoubledeckFirstEconomyClass: 'DOUBLEDECK_FIRST_ECONOMY_CLASS',
  DoubledeckFirstClass: 'DOUBLEDECK_FIRST_CLASS',
  DoubledeckEconomyClass: 'DOUBLEDECK_ECONOMY_CLASS',
  DoubledeckControlcarFirstEconomoyClass:
    'DOUBLEDECK_CONTROLCAR_FIRST_ECONOMOY_CLASS',
  DoubledeckControlcarFirstClass: 'DOUBLEDECK_CONTROLCAR_FIRST_CLASS',
  DoubledeckControlcarEconomyClass: 'DOUBLEDECK_CONTROLCAR_ECONOMY_CLASS',
  DoubledeckCarcarrierPassengertrain: 'DOUBLEDECK_CARCARRIER_PASSENGERTRAIN',
  PassengercarriageFirstEconomyClass: 'PASSENGERCARRIAGE_FIRST_ECONOMY_CLASS',
  PassengercarriageFirstClass: 'PASSENGERCARRIAGE_FIRST_CLASS',
  PassengercarriageEconomyClass: 'PASSENGERCARRIAGE_ECONOMY_CLASS',
  ControlcarFirstClass: 'CONTROLCAR_FIRST_CLASS',
  ControlcarEconomyClass: 'CONTROLCAR_ECONOMY_CLASS',
  ControlcarFirstEconomyClass: 'CONTROLCAR_FIRST_ECONOMY_CLASS',
  DoublecontrolcarEconomyClass: 'DOUBLECONTROLCAR_ECONOMY_CLASS',
  DoublecontrolcarFirstEconomyClass: 'DOUBLECONTROLCAR_FIRST_ECONOMY_CLASS',
  Diningcar: 'DININGCAR',
  HalfdiningcarFirstClass: 'HALFDININGCAR_FIRST_CLASS',
  HalfdiningcarEconomyClass: 'HALFDININGCAR_ECONOMY_CLASS',
  SleeperFirstClass: 'SLEEPER_FIRST_CLASS',
  SleeperFirstEconomyClass: 'SLEEPER_FIRST_ECONOMY_CLASS',
  SleeperEconomyClass: 'SLEEPER_ECONOMY_CLASS',
  CouchetteFirstClass: 'COUCHETTE_FIRST_CLASS',
  CouchetteEconomyClass: 'COUCHETTE_ECONOMY_CLASS',
  Baggagecar: 'BAGGAGECAR',
  Halfbaggagecar: 'HALFBAGGAGECAR',
  Locomotive: 'LOCOMOTIVE',
  Powercar: 'POWERCAR',
  Undefined: 'UNDEFINED',
} as const;

export type VehicleCategory =
  (typeof VehicleCategory)[keyof typeof VehicleCategory];

/**
 * Vehicle group [Fahrzeuggruppe] within the vehicle sequence [Wagenreihung] containing at least one vehicle [Fahrzeug] for arrival [Ankunft].
 * @export
 * @interface VehicleGroupInSequenceArrival
 */
export interface VehicleGroupInSequenceArrival {
  /**
   * Name of the vehicle group within the sequence.
   * @type {string}
   * @memberof VehicleGroupInSequenceArrival
   */
  name: string;
  /**
   *
   * @type {TransportPublicOrigin}
   * @memberof VehicleGroupInSequenceArrival
   */
  transport: TransportPublicOrigin;
  /**
   * Vehicles within the group ordered in direction of travel, including informations only valid within the sequence.
   * @type {Array<VehicleInGroup>}
   * @memberof VehicleGroupInSequenceArrival
   */
  vehicles: Array<VehicleInGroup>;
}
/**
 * Vehicle group [Fahrzeuggruppe] within the vehicle sequence [Wagenreihung] containing at least one vehicle [Fahrzeug] for departure [Abfahrt].
 * @export
 * @interface VehicleGroupInSequenceDeparture
 */
export interface VehicleGroupInSequenceDeparture {
  /**
   * Name of the vehicle group within the sequence.
   * @type {string}
   * @memberof VehicleGroupInSequenceDeparture
   */
  name: string;
  /**
   *
   * @type {TransportPublicDestination}
   * @memberof VehicleGroupInSequenceDeparture
   */
  transport: TransportPublicDestination;
  /**
   *
   * @type {Occupancy}
   * @memberof VehicleGroupInSequenceDeparture
   */
  occupancy?: Occupancy;
  /**
   * Vehicles within the group ordered in direction of travel, including informations only valid within the sequence.
   * @type {Array<VehicleInGroup>}
   * @memberof VehicleGroupInSequenceDeparture
   */
  vehicles: Array<VehicleInGroup>;
}
/**
 * Vehicle information for a vehicle [Fahrzeug] within a vehicle group [Fahrzeuggruppe] within a vehicle sequence.
 * @export
 * @interface VehicleInGroup
 */
export interface VehicleInGroup {
  /**
   * ID of the vehicle (for rail vehicles usually the UIC identification nunmber).
   * @type {string}
   * @memberof VehicleInGroup
   */
  vehicleID: string;
  /**
   *
   * @type {VehicleType}
   * @memberof VehicleInGroup
   */
  type: VehicleType;
  /**
   * Wagon identification number [Ordnungsnummer] of the vehicle. May be empty, if no unique identification of a wagon is needed.
   * @type {number}
   * @memberof VehicleInGroup
   */
  wagonIdentificationNumber?: number;
  /**
   *
   * @type {VehicleStatus}
   * @memberof VehicleInGroup
   */
  status: VehicleStatus;
  /**
   *
   * @type {VehicleOrientation}
   * @memberof VehicleInGroup
   */
  orientation: VehicleOrientation;
  /**
   *
   * @type {VehiclePlatformPosition}
   * @memberof VehicleInGroup
   */
  platformPosition?: VehiclePlatformPosition;
  /**
   * Amount and status of vehicle amenities [Ausstattungsmerkmale].
   * @type {Array<VehicleAmenity>}
   * @memberof VehicleInGroup
   */
  amenities: Array<VehicleAmenity>;
  /**
   *
   * @type {Occupancy}
   * @memberof VehicleInGroup
   */
  occupancy?: Occupancy;
}

/**
 * Orientation of vehicle [Fahrzeug].  - FORWARDS (Relative orientation forwards [Vorwaerts])  - BACKWARDS (Relative orientation backwards [Rueckwaerts])  - UNDEFINED (Undefined orientation)
 * @export
 * @enum {string}
 */

export const VehicleOrientation = {
  Forwards: 'FORWARDS',
  Backwards: 'BACKWARDS',
  Undefined: 'UNDEFINED',
} as const;

export type VehicleOrientation =
  (typeof VehicleOrientation)[keyof typeof VehicleOrientation];

/**
 * Position of a vehicle [Fahrzeug] at a platform [Gleis, Bahnsteig, Plattform].
 * @export
 * @interface VehiclePlatformPosition
 */
export interface VehiclePlatformPosition {
  /**
   * Start position [Beginn Meter] at the platform given in meters in local coordinates.
   * @type {number}
   * @memberof VehiclePlatformPosition
   */
  start: number;
  /**
   * End position [Ende Meter] at the platform given in meters in local coordinates.
   * @type {number}
   * @memberof VehiclePlatformPosition
   */
  end: number;
  /**
   * Sector [Sektor] the major part of the vehicle is located in. May be empty in case the platform has no sectors.
   * @type {string}
   * @memberof VehiclePlatformPosition
   */
  sector?: string;
}
/**
 * Vehicle sequence [Wagenreihung] for transports at a particular arrival.
 * @export
 * @interface VehicleSequenceArrival
 */
export interface VehicleSequenceArrival {
  /**
   * ID of the requested journey [FahrtID].
   * @type {string}
   * @memberof VehicleSequenceArrival
   */
  journeyID: string;
  /**
   * ID of the requested arrival [AnkunftsID].
   * @type {string}
   * @memberof VehicleSequenceArrival
   */
  arrivalID: string;
  /**
   * Name of the scheduled arrival platform [Plattform Soll].
   * @type {string}
   * @memberof VehicleSequenceArrival
   */
  arrivalPlatformSchedule?: string;
  /**
   * Name of the estimated arrival platform [Plattform Vorschau]. Note that there might be no information on the estimated arrival platform (due to various reasons); in this case the attribute platform will also be empty.
   * @type {string}
   * @memberof VehicleSequenceArrival
   */
  arrivalPlatform?: string;
  /**
   *
   * @type {Platform}
   * @memberof VehicleSequenceArrival
   */
  platform?: Platform;
  /**
   *
   * @type {VehicleSequenceStatus}
   * @memberof VehicleSequenceArrival
   */
  sequenceStatus: VehicleSequenceStatus;
  /**
   * Vehicle groups [Fahrzeuggruppen] of the transport ordered in direction of travel.
   * @type {Array<VehicleGroupInSequenceArrival>}
   * @memberof VehicleSequenceArrival
   */
  groups: Array<VehicleGroupInSequenceArrival>;
}

/**
 * Administrations [Verwaltung] that provide vehicle sequences [Wagenreihung].
 * @export
 * @interface VehicleSequenceAvailableAdministrations
 */
export interface VehicleSequenceAvailableAdministrations {
  /**
   * List of administrations.
   * @type {Array<Administration>}
   * @memberof VehicleSequenceAvailableAdministrations
   */
  administrations: Array<Administration>;
}
/**
 * Vehicle sequence [Wagenreihung] for transports at a particular departure.
 * @export
 * @interface VehicleSequenceDeparture
 */
export interface VehicleSequenceDeparture {
  /**
   * ID of the requested journey [FahrtID].
   * @type {string}
   * @memberof VehicleSequenceDeparture
   */
  journeyID: string;
  /**
   * ID of the requested departure [AbfahrtID].
   * @type {string}
   * @memberof VehicleSequenceDeparture
   */
  departureID: string;
  /**
   * Name of the scheduled departure platform [Plattform Soll].
   * @type {string}
   * @memberof VehicleSequenceDeparture
   */
  departurePlatformSchedule?: string;
  /**
   * Name of the estimated departure platform [Plattform Vorschau]. Note that there might be no information on the estimated departure platform (due to various reasons); in this case the attribute platform will also be empty.
   * @type {string}
   * @memberof VehicleSequenceDeparture
   */
  departurePlatform?: string;
  /**
   *
   * @type {Platform}
   * @memberof VehicleSequenceDeparture
   */
  platform?: Platform;
  /**
   *
   * @type {VehicleSequenceStatus}
   * @memberof VehicleSequenceDeparture
   */
  sequenceStatus: VehicleSequenceStatus;
  /**
   *
   * @type {Occupancy}
   * @memberof VehicleSequenceDeparture
   */
  occupancy?: Occupancy;
  /**
   * Vehicle groups [Fahrzeuggruppen] of the transport ordered in direction of travel.
   * @type {Array<VehicleGroupInSequenceDeparture>}
   * @memberof VehicleSequenceDeparture
   */
  groups: Array<VehicleGroupInSequenceDeparture>;
}

/**
 * Reflects vehicle sequence [Wagenreihung] status with respect to order of first and economy class.  - MATCHES_SCHEDULE (The current sequence matches the scheduled order.) - DIFFERS_FROM_SCHEDULE (The current sequence differs from the scheduled order.) - NO_SCHEDULE (There is no scheduled sequence.)
 * @export
 * @enum {string}
 */

export const VehicleSequenceStatus = {
  MatchesSchedule: 'MATCHES_SCHEDULE',
  DiffersFromSchedule: 'DIFFERS_FROM_SCHEDULE',
  NoSchedule: 'NO_SCHEDULE',
} as const;

export type VehicleSequenceStatus =
  (typeof VehicleSequenceStatus)[keyof typeof VehicleSequenceStatus];

/**
 * Status of vehicle [Fahrzeug] with respect to accessibility for passengers. - OPEN  (Vehicle is open [Offen] - CLOSED (Vehicle is closed [Geschlossen]
 * @export
 * @enum {string}
 */

export const VehicleStatus = {
  Open: 'OPEN',
  Closed: 'CLOSED',
} as const;

export type VehicleStatus = (typeof VehicleStatus)[keyof typeof VehicleStatus];

/**
 * Detailed information on the vehicle [Fahrzeug] type.
 * @export
 * @interface VehicleType
 */
export interface VehicleType {
  /**
   *
   * @type {VehicleCategory}
   * @memberof VehicleType
   */
  category: VehicleCategory;
  /**
   * Construction type of the vehicle [Bauart bzw. Baureihe], for instance \'I4030\' or \'If03F \'.
   * @type {string}
   * @memberof VehicleType
   */
  constructionType: string;
  /**
   * Indicates if the vehicle has first class seats.
   * @type {boolean}
   * @memberof VehicleType
   */
  hasFirstClass: boolean;
  /**
   * Indicates if the vehicle has economy class seats.
   * @type {boolean}
   * @memberof VehicleType
   */
  hasEconomyClass: boolean;
  /**
   * ID of the layout [Redesign, mit grünem Streifem etc.] of the vehicle type, for instance \'403.1.BS\' or \'403.2.BS\'.
   * @type {string}
   * @memberof VehicleType
   */
  layoutID?: string;
}

/**
 * OccupanciesApi - axios parameter creator
 * @export
 */
export const OccupanciesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * PREVIEW Returns occupancies [Auslastung] for a particular departrue [Abfahrt] within a journey [Fahrt]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary Returns occupancies for a departure within a journey
     * @param {string} date calendar date [Kalendertag] of transports departure (\&#39;YYYY-MM-dd\&#39;)
     * @param {number} number number of journey [Fahrtnummer] at departure
     * @param {string} category category [Fahrtgattung] of transport at departure
     * @param {string} evaNumber eva number of departure stop-place [Haltestelle]
     * @param {string} [timeSchedule] scheduled departure time [Geplante Abfahrtzeit] at stop-place [Haltestelle] as time (\&#39;HH:mm:ss\&#39;), only necessary to identify multiple stops at the same stop-place within a particular journey [Schleifenfahrten]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByDepartureUnmatched: async (
      date: string,
      number: number,
      category: string,
      evaNumber: string,
      timeSchedule?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists('occupancyByDepartureUnmatched', 'date', date);
      // verify required parameter 'number' is not null or undefined
      assertParamExists('occupancyByDepartureUnmatched', 'number', number);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('occupancyByDepartureUnmatched', 'category', category);
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists(
        'occupancyByDepartureUnmatched',
        'evaNumber',
        evaNumber,
      );
      const localVarPath = `/occupancies/departures/unmatched`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substring(0, 10)
            : date;
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (evaNumber !== undefined) {
        localVarQueryParameter['evaNumber'] = evaNumber;
      }

      if (timeSchedule !== undefined) {
        localVarQueryParameter['timeSchedule'] = timeSchedule;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt]. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {string} journeyID id of journey [Fahrt-ID]
     * @param {string} [departureID] id of departure [Abfahrt-ID], if omitted all departures with occupancy information are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByJourneyId: async (
      journeyID: string,
      departureID?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'journeyID' is not null or undefined
      assertParamExists('occupancyByJourneyId', 'journeyID', journeyID);
      const localVarPath = `/occupancies/{journeyID}`.replace(
        `{${'journeyID'}}`,
        encodeURIComponent(String(journeyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (departureID !== undefined) {
        localVarQueryParameter['departureID'] = departureID;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt] and all its departures [Abfahrten]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {string} startTime scheduled start time [Geplante Startzeit] of transport at scheduled start stop-place [Geplanter Starthalt] as fully-qualified-date (ISO-8601 with time-zone or offset)
     * @param {string} startCategory category [Fahrtgattung] of transport at scheduled start stop-place [Geplanter Starthalt]
     * @param {number} startNumber number of journey [Fahrtnummer] at scheduled start stop-place [Geplanter Starthalt]
     * @param {string} [startEvaNumber] eva number of scheduled start stop-place [Geplanter Starthalt] of transport
     * @param {string} [startAdministrationID] id of the administration [Verwaltung] of transport at scheduled start stop-place [Geplanter Starthalt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByJourneyUnmatched: async (
      startTime: string,
      startCategory: string,
      startNumber: number,
      startEvaNumber?: string,
      startAdministrationID?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'startTime' is not null or undefined
      assertParamExists('occupancyByJourneyUnmatched', 'startTime', startTime);
      // verify required parameter 'startCategory' is not null or undefined
      assertParamExists(
        'occupancyByJourneyUnmatched',
        'startCategory',
        startCategory,
      );
      // verify required parameter 'startNumber' is not null or undefined
      assertParamExists(
        'occupancyByJourneyUnmatched',
        'startNumber',
        startNumber,
      );
      const localVarPath = `/occupancies/unmatched`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime;
      }

      if (startEvaNumber !== undefined) {
        localVarQueryParameter['startEvaNumber'] = startEvaNumber;
      }

      if (startAdministrationID !== undefined) {
        localVarQueryParameter['startAdministrationID'] = startAdministrationID;
      }

      if (startCategory !== undefined) {
        localVarQueryParameter['startCategory'] = startCategory;
      }

      if (startNumber !== undefined) {
        localVarQueryParameter['startNumber'] = startNumber;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OccupanciesApi - functional programming interface
 * @export
 */
export const OccupanciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OccupanciesApiAxiosParamCreator(configuration);
  return {
    /**
     * PREVIEW Returns occupancies [Auslastung] for a particular departrue [Abfahrt] within a journey [Fahrt]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary Returns occupancies for a departure within a journey
     * @param {string} date calendar date [Kalendertag] of transports departure (\&#39;YYYY-MM-dd\&#39;)
     * @param {number} number number of journey [Fahrtnummer] at departure
     * @param {string} category category [Fahrtgattung] of transport at departure
     * @param {string} evaNumber eva number of departure stop-place [Haltestelle]
     * @param {string} [timeSchedule] scheduled departure time [Geplante Abfahrtzeit] at stop-place [Haltestelle] as time (\&#39;HH:mm:ss\&#39;), only necessary to identify multiple stops at the same stop-place within a particular journey [Schleifenfahrten]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async occupancyByDepartureUnmatched(
      date: string,
      number: number,
      category: string,
      evaNumber: string,
      timeSchedule?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JourneyOccupancyUnmatched>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.occupancyByDepartureUnmatched(
          date,
          number,
          category,
          evaNumber,
          timeSchedule,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt]. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {string} journeyID id of journey [Fahrt-ID]
     * @param {string} [departureID] id of departure [Abfahrt-ID], if omitted all departures with occupancy information are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async occupancyByJourneyId(
      journeyID: string,
      departureID?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JourneyOccupancy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.occupancyByJourneyId(
          journeyID,
          departureID,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt] and all its departures [Abfahrten]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {string} startTime scheduled start time [Geplante Startzeit] of transport at scheduled start stop-place [Geplanter Starthalt] as fully-qualified-date (ISO-8601 with time-zone or offset)
     * @param {string} startCategory category [Fahrtgattung] of transport at scheduled start stop-place [Geplanter Starthalt]
     * @param {number} startNumber number of journey [Fahrtnummer] at scheduled start stop-place [Geplanter Starthalt]
     * @param {string} [startEvaNumber] eva number of scheduled start stop-place [Geplanter Starthalt] of transport
     * @param {string} [startAdministrationID] id of the administration [Verwaltung] of transport at scheduled start stop-place [Geplanter Starthalt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async occupancyByJourneyUnmatched(
      startTime: string,
      startCategory: string,
      startNumber: number,
      startEvaNumber?: string,
      startAdministrationID?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JourneyOccupancyUnmatched>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.occupancyByJourneyUnmatched(
          startTime,
          startCategory,
          startNumber,
          startEvaNumber,
          startAdministrationID,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * OccupanciesApi - factory interface
 * @export
 */
export const OccupanciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OccupanciesApiFp(configuration);
  return {
    /**
     * PREVIEW Returns occupancies [Auslastung] for a particular departrue [Abfahrt] within a journey [Fahrt]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary Returns occupancies for a departure within a journey
     * @param {OccupanciesApiOccupancyByDepartureUnmatchedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByDepartureUnmatched(
      requestParameters: OccupanciesApiOccupancyByDepartureUnmatchedRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<JourneyOccupancyUnmatched> {
      return localVarFp
        .occupancyByDepartureUnmatched(
          requestParameters.date,
          requestParameters.number,
          requestParameters.category,
          requestParameters.evaNumber,
          requestParameters.timeSchedule,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt]. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {OccupanciesApiOccupancyByJourneyIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByJourneyId(
      requestParameters: OccupanciesApiOccupancyByJourneyIdRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<JourneyOccupancy> {
      return localVarFp
        .occupancyByJourneyId(
          requestParameters.journeyID,
          requestParameters.departureID,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns occupancies [Auslastung] for a particular journey [Fahrt] and all its departures [Abfahrten]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
     * @summary PREVIEW Returns occupancies for a journey
     * @param {OccupanciesApiOccupancyByJourneyUnmatchedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByJourneyUnmatched(
      requestParameters: OccupanciesApiOccupancyByJourneyUnmatchedRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<JourneyOccupancyUnmatched> {
      return localVarFp
        .occupancyByJourneyUnmatched(
          requestParameters.startTime,
          requestParameters.startCategory,
          requestParameters.startNumber,
          requestParameters.startEvaNumber,
          requestParameters.startAdministrationID,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for occupancyByDepartureUnmatched operation in OccupanciesApi.
 * @export
 * @interface OccupanciesApiOccupancyByDepartureUnmatchedRequest
 */
export interface OccupanciesApiOccupancyByDepartureUnmatchedRequest {
  /**
   * calendar date [Kalendertag] of transports departure (\&#39;YYYY-MM-dd\&#39;)
   * @type {string}
   * @memberof OccupanciesApiOccupancyByDepartureUnmatched
   */
  readonly date: string;

  /**
   * number of journey [Fahrtnummer] at departure
   * @type {number}
   * @memberof OccupanciesApiOccupancyByDepartureUnmatched
   */
  readonly number: number;

  /**
   * category [Fahrtgattung] of transport at departure
   * @type {string}
   * @memberof OccupanciesApiOccupancyByDepartureUnmatched
   */
  readonly category: string;

  /**
   * eva number of departure stop-place [Haltestelle]
   * @type {string}
   * @memberof OccupanciesApiOccupancyByDepartureUnmatched
   */
  readonly evaNumber: string;

  /**
   * scheduled departure time [Geplante Abfahrtzeit] at stop-place [Haltestelle] as time (\&#39;HH:mm:ss\&#39;), only necessary to identify multiple stops at the same stop-place within a particular journey [Schleifenfahrten]
   * @type {string}
   * @memberof OccupanciesApiOccupancyByDepartureUnmatched
   */
  readonly timeSchedule?: string;
}

/**
 * Request parameters for occupancyByJourneyId operation in OccupanciesApi.
 * @export
 * @interface OccupanciesApiOccupancyByJourneyIdRequest
 */
export interface OccupanciesApiOccupancyByJourneyIdRequest {
  /**
   * id of journey [Fahrt-ID]
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyId
   */
  readonly journeyID: string;

  /**
   * id of departure [Abfahrt-ID], if omitted all departures with occupancy information are returned
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyId
   */
  readonly departureID?: string;
}

/**
 * Request parameters for occupancyByJourneyUnmatched operation in OccupanciesApi.
 * @export
 * @interface OccupanciesApiOccupancyByJourneyUnmatchedRequest
 */
export interface OccupanciesApiOccupancyByJourneyUnmatchedRequest {
  /**
   * scheduled start time [Geplante Startzeit] of transport at scheduled start stop-place [Geplanter Starthalt] as fully-qualified-date (ISO-8601 with time-zone or offset)
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyUnmatched
   */
  readonly startTime: string;

  /**
   * category [Fahrtgattung] of transport at scheduled start stop-place [Geplanter Starthalt]
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyUnmatched
   */
  readonly startCategory: string;

  /**
   * number of journey [Fahrtnummer] at scheduled start stop-place [Geplanter Starthalt]
   * @type {number}
   * @memberof OccupanciesApiOccupancyByJourneyUnmatched
   */
  readonly startNumber: number;

  /**
   * eva number of scheduled start stop-place [Geplanter Starthalt] of transport
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyUnmatched
   */
  readonly startEvaNumber?: string;

  /**
   * id of the administration [Verwaltung] of transport at scheduled start stop-place [Geplanter Starthalt]
   * @type {string}
   * @memberof OccupanciesApiOccupancyByJourneyUnmatched
   */
  readonly startAdministrationID?: string;
}

/**
 * OccupanciesApi - object-oriented interface
 * @export
 * @class OccupanciesApi
 * @extends {BaseAPI}
 */
export class OccupanciesApi extends BaseAPI {
  /**
   * PREVIEW Returns occupancies [Auslastung] for a particular departrue [Abfahrt] within a journey [Fahrt]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
   * @summary Returns occupancies for a departure within a journey
   * @param {OccupanciesApiOccupancyByDepartureUnmatchedRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OccupanciesApi
   */
  public occupancyByDepartureUnmatched(
    requestParameters: OccupanciesApiOccupancyByDepartureUnmatchedRequest,
    options?: AxiosRequestConfig,
  ) {
    return OccupanciesApiFp(this.configuration)
      .occupancyByDepartureUnmatched(
        requestParameters.date,
        requestParameters.number,
        requestParameters.category,
        requestParameters.evaNumber,
        requestParameters.timeSchedule,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns occupancies [Auslastung] for a particular journey [Fahrt]. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
   * @summary PREVIEW Returns occupancies for a journey
   * @param {OccupanciesApiOccupancyByJourneyIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OccupanciesApi
   */
  public occupancyByJourneyId(
    requestParameters: OccupanciesApiOccupancyByJourneyIdRequest,
    options?: AxiosRequestConfig,
  ) {
    return OccupanciesApiFp(this.configuration)
      .occupancyByJourneyId(
        requestParameters.journeyID,
        requestParameters.departureID,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns occupancies [Auslastung] for a particular journey [Fahrt] and all its departures [Abfahrten]. This is the unmatched entrypoint in case the caller is not aware of the particular \'journeyID\' and \'departureID\'. Be aware that in case the combination of filters, that are used to identify the journey or its departure, doesn\'t result in a unique match that an exception is thrown. **NOTE:** _This feature is currently in preview and responses only contain dummy-data._
   * @summary PREVIEW Returns occupancies for a journey
   * @param {OccupanciesApiOccupancyByJourneyUnmatchedRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OccupanciesApi
   */
  public occupancyByJourneyUnmatched(
    requestParameters: OccupanciesApiOccupancyByJourneyUnmatchedRequest,
    options?: AxiosRequestConfig,
  ) {
    return OccupanciesApiFp(this.configuration)
      .occupancyByJourneyUnmatched(
        requestParameters.startTime,
        requestParameters.startCategory,
        requestParameters.startNumber,
        requestParameters.startEvaNumber,
        requestParameters.startAdministrationID,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransportsApi - axios parameter creator
 * @export
 */
export const TransportsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all journeys [Fahrten] that contain a vehicle [Fahrzeug] with a matching vehicle id order by scheduled deparute time asc. May contain outdated and / or future journeys.
     * @param {string} vehicleID id for vehicle (for rail vehicles usually the UIC identification nunmber)
     * @param {string} [date] scheduled departure / arrival date to limit returned vehicles for, if omitted defaults to today
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchingVehicleID: async (
      vehicleID: string,
      date?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'vehicleID' is not null or undefined
      assertParamExists('matchingVehicleID', 'vehicleID', vehicleID);
      const localVarPath = `/by-vehicleid/{vehicleID}`.replace(
        `{${'vehicleID'}}`,
        encodeURIComponent(String(vehicleID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substring(0, 10)
            : date;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all administrations [Verwaltungen] that provide vehicle sequences [Wagenreihungen].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceAdministrations: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vehicle-sequences/administrations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {string} date date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
     * @param {string} category category of transport [Fahrtgattung]
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} evaNumber arrival station id [Abfahrt] for desired arrival
     * @param {string} time scheduled arrival time [Geplante Ankunftszeit] for desired arrival as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceArrivalUnmatched: async (
      date: string,
      category: string,
      number: number,
      evaNumber: string,
      time: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists('vehicleSequenceArrivalUnmatched', 'date', date);
      // verify required parameter 'category' is not null or undefined
      assertParamExists(
        'vehicleSequenceArrivalUnmatched',
        'category',
        category,
      );
      // verify required parameter 'number' is not null or undefined
      assertParamExists('vehicleSequenceArrivalUnmatched', 'number', number);
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists(
        'vehicleSequenceArrivalUnmatched',
        'evaNumber',
        evaNumber,
      );
      // verify required parameter 'time' is not null or undefined
      assertParamExists('vehicleSequenceArrivalUnmatched', 'time', time);
      const localVarPath = `/vehicle-sequences/by-arrival`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substring(0, 10)
            : date;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (evaNumber !== undefined) {
        localVarQueryParameter['evaNumber'] = evaNumber;
      }

      if (time !== undefined) {
        localVarQueryParameter['time'] =
          (time as any) instanceof Date ? (time as any).toISOString() : time;
      }

      if (includePosition !== undefined) {
        localVarQueryParameter['includePosition'] = includePosition;
      }

      if (includeAmenities !== undefined) {
        localVarQueryParameter['includeAmenities'] = includeAmenities;
      }

      if (includeOccupancy !== undefined) {
        localVarQueryParameter['includeOccupancy'] = includeOccupancy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmalen] and occupancy [Auslastung] for a particular departure.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {string} departureID id of departure [AbfahrtID]
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceDeparture: async (
      journeyID: string,
      departureID: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'journeyID' is not null or undefined
      assertParamExists('vehicleSequenceDeparture', 'journeyID', journeyID);
      // verify required parameter 'departureID' is not null or undefined
      assertParamExists('vehicleSequenceDeparture', 'departureID', departureID);
      const localVarPath =
        `/vehicle-sequences/by-departure/{journeyID}/{departureID}`
          .replace(`{${'journeyID'}}`, encodeURIComponent(String(journeyID)))
          .replace(
            `{${'departureID'}}`,
            encodeURIComponent(String(departureID)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (includePosition !== undefined) {
        localVarQueryParameter['includePosition'] = includePosition;
      }

      if (includeAmenities !== undefined) {
        localVarQueryParameter['includeAmenities'] = includeAmenities;
      }

      if (includeOccupancy !== undefined) {
        localVarQueryParameter['includeOccupancy'] = includeOccupancy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {string} date date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
     * @param {string} category category of transport [Fahrtgattung]
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} evaNumber departure station id [Abfahrt] for desired departure
     * @param {string} time scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceDepartureUnmatched: async (
      date: string,
      category: string,
      number: number,
      evaNumber: string,
      time: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists('vehicleSequenceDepartureUnmatched', 'date', date);
      // verify required parameter 'category' is not null or undefined
      assertParamExists(
        'vehicleSequenceDepartureUnmatched',
        'category',
        category,
      );
      // verify required parameter 'number' is not null or undefined
      assertParamExists('vehicleSequenceDepartureUnmatched', 'number', number);
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists(
        'vehicleSequenceDepartureUnmatched',
        'evaNumber',
        evaNumber,
      );
      // verify required parameter 'time' is not null or undefined
      assertParamExists('vehicleSequenceDepartureUnmatched', 'time', time);
      const localVarPath = `/vehicle-sequences/by-departure`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date
            ? (date as any).toISOString().substring(0, 10)
            : date;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (evaNumber !== undefined) {
        localVarQueryParameter['evaNumber'] = evaNumber;
      }

      if (time !== undefined) {
        localVarQueryParameter['time'] =
          (time as any) instanceof Date ? (time as any).toISOString() : time;
      }

      if (includePosition !== undefined) {
        localVarQueryParameter['includePosition'] = includePosition;
      }

      if (includeAmenities !== undefined) {
        localVarQueryParameter['includeAmenities'] = includeAmenities;
      }

      if (includeOccupancy !== undefined) {
        localVarQueryParameter['includeOccupancy'] = includeOccupancy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransportsApi - functional programming interface
 * @export
 */
export const TransportsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransportsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all journeys [Fahrten] that contain a vehicle [Fahrzeug] with a matching vehicle id order by scheduled deparute time asc. May contain outdated and / or future journeys.
     * @param {string} vehicleID id for vehicle (for rail vehicles usually the UIC identification nunmber)
     * @param {string} [date] scheduled departure / arrival date to limit returned vehicles for, if omitted defaults to today
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async matchingVehicleID(
      vehicleID: string,
      date?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TransportMatchVehicleIDs>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.matchingVehicleID(
          vehicleID,
          date,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all administrations [Verwaltungen] that provide vehicle sequences [Wagenreihungen].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehicleSequenceAdministrations(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VehicleSequenceAvailableAdministrations>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vehicleSequenceAdministrations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {string} date date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
     * @param {string} category category of transport [Fahrtgattung]
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} evaNumber arrival station id [Abfahrt] for desired arrival
     * @param {string} time scheduled arrival time [Geplante Ankunftszeit] for desired arrival as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehicleSequenceArrivalUnmatched(
      date: string,
      category: string,
      number: number,
      evaNumber: string,
      time: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VehicleSequenceArrival>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vehicleSequenceArrivalUnmatched(
          date,
          category,
          number,
          evaNumber,
          time,
          includePosition,
          includeAmenities,
          includeOccupancy,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmalen] and occupancy [Auslastung] for a particular departure.
     * @param {string} journeyID id of journey [FahrtID]
     * @param {string} departureID id of departure [AbfahrtID]
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehicleSequenceDeparture(
      journeyID: string,
      departureID: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VehicleSequenceDeparture>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vehicleSequenceDeparture(
          journeyID,
          departureID,
          includePosition,
          includeAmenities,
          includeOccupancy,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {string} date date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
     * @param {string} category category of transport [Fahrtgattung]
     * @param {number} number number of transport [Fahrtnummer]
     * @param {string} evaNumber departure station id [Abfahrt] for desired departure
     * @param {string} time scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
     * @param {boolean} [includePosition] include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
     * @param {boolean} [includeAmenities] include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
     * @param {OccupancyDetail} [includeOccupancy] include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehicleSequenceDepartureUnmatched(
      date: string,
      category: string,
      number: number,
      evaNumber: string,
      time: string,
      includePosition?: boolean,
      includeAmenities?: boolean,
      includeOccupancy?: OccupancyDetail,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VehicleSequenceDeparture>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vehicleSequenceDepartureUnmatched(
          date,
          category,
          number,
          evaNumber,
          time,
          includePosition,
          includeAmenities,
          includeOccupancy,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TransportsApi - factory interface
 * @export
 */
export const TransportsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransportsApiFp(configuration);
  return {
    /**
     * Returns all journeys [Fahrten] that contain a vehicle [Fahrzeug] with a matching vehicle id order by scheduled deparute time asc. May contain outdated and / or future journeys.
     * @param {TransportsApiMatchingVehicleIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchingVehicleID(
      requestParameters: TransportsApiMatchingVehicleIDRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TransportMatchVehicleIDs> {
      return localVarFp
        .matchingVehicleID(
          requestParameters.vehicleID,
          requestParameters.date,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all administrations [Verwaltungen] that provide vehicle sequences [Wagenreihungen].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceAdministrations(
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleSequenceAvailableAdministrations> {
      return localVarFp
        .vehicleSequenceAdministrations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {TransportsApiVehicleSequenceArrivalUnmatchedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceArrivalUnmatched(
      requestParameters: TransportsApiVehicleSequenceArrivalUnmatchedRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleSequenceArrival> {
      return localVarFp
        .vehicleSequenceArrivalUnmatched(
          requestParameters.date,
          requestParameters.category,
          requestParameters.number,
          requestParameters.evaNumber,
          requestParameters.time,
          requestParameters.includePosition,
          requestParameters.includeAmenities,
          requestParameters.includeOccupancy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmalen] and occupancy [Auslastung] for a particular departure.
     * @param {TransportsApiVehicleSequenceDepartureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceDeparture(
      requestParameters: TransportsApiVehicleSequenceDepartureRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleSequenceDeparture> {
      return localVarFp
        .vehicleSequenceDeparture(
          requestParameters.journeyID,
          requestParameters.departureID,
          requestParameters.includePosition,
          requestParameters.includeAmenities,
          requestParameters.includeOccupancy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
     * @param {TransportsApiVehicleSequenceDepartureUnmatchedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehicleSequenceDepartureUnmatched(
      requestParameters: TransportsApiVehicleSequenceDepartureUnmatchedRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleSequenceDeparture> {
      return localVarFp
        .vehicleSequenceDepartureUnmatched(
          requestParameters.date,
          requestParameters.category,
          requestParameters.number,
          requestParameters.evaNumber,
          requestParameters.time,
          requestParameters.includePosition,
          requestParameters.includeAmenities,
          requestParameters.includeOccupancy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for matchingVehicleID operation in TransportsApi.
 * @export
 * @interface TransportsApiMatchingVehicleIDRequest
 */
export interface TransportsApiMatchingVehicleIDRequest {
  /**
   * id for vehicle (for rail vehicles usually the UIC identification nunmber)
   * @type {string}
   * @memberof TransportsApiMatchingVehicleID
   */
  readonly vehicleID: string;

  /**
   * scheduled departure / arrival date to limit returned vehicles for, if omitted defaults to today
   * @type {string}
   * @memberof TransportsApiMatchingVehicleID
   */
  readonly date?: string;
}

/**
 * Request parameters for vehicleSequenceArrivalUnmatched operation in TransportsApi.
 * @export
 * @interface TransportsApiVehicleSequenceArrivalUnmatchedRequest
 */
export interface TransportsApiVehicleSequenceArrivalUnmatchedRequest {
  /**
   * date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly date: string;

  /**
   * category of transport [Fahrtgattung]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly category: string;

  /**
   * number of transport [Fahrtnummer]
   * @type {number}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly number: number;

  /**
   * arrival station id [Abfahrt] for desired arrival
   * @type {string}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly evaNumber: string;

  /**
   * scheduled arrival time [Geplante Ankunftszeit] for desired arrival as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
   * @type {string}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly time: string;

  /**
   * include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly includePosition?: boolean;

  /**
   * include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly includeAmenities?: boolean;

  /**
   * include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
   * @type {OccupancyDetail}
   * @memberof TransportsApiVehicleSequenceArrivalUnmatched
   */
  readonly includeOccupancy?: OccupancyDetail;
}

/**
 * Request parameters for vehicleSequenceDeparture operation in TransportsApi.
 * @export
 * @interface TransportsApiVehicleSequenceDepartureRequest
 */
export interface TransportsApiVehicleSequenceDepartureRequest {
  /**
   * id of journey [FahrtID]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDeparture
   */
  readonly journeyID: string;

  /**
   * id of departure [AbfahrtID]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDeparture
   */
  readonly departureID: string;

  /**
   * include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceDeparture
   */
  readonly includePosition?: boolean;

  /**
   * include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceDeparture
   */
  readonly includeAmenities?: boolean;

  /**
   * include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
   * @type {OccupancyDetail}
   * @memberof TransportsApiVehicleSequenceDeparture
   */
  readonly includeOccupancy?: OccupancyDetail;
}

/**
 * Request parameters for vehicleSequenceDepartureUnmatched operation in TransportsApi.
 * @export
 * @interface TransportsApiVehicleSequenceDepartureUnmatchedRequest
 */
export interface TransportsApiVehicleSequenceDepartureUnmatchedRequest {
  /**
   * date (yyyy-mm-dd) of scheduled start of journey [Verkehrstag]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly date: string;

  /**
   * category of transport [Fahrtgattung]
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly category: string;

  /**
   * number of transport [Fahrtnummer]
   * @type {number}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly number: number;

  /**
   * departure station id [Abfahrt] for desired departure
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly evaNumber: string;

  /**
   * scheduled departure time [Geplante Abfahrtszeit] for desired departure as fully qualified datetime (ISO8601 with timezone / offset, for instance yyyy-MM-ddTHH:mm:ssZ)
   * @type {string}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly time: string;

  /**
   * include position at platform [Gleis, Bahnsteig, Plattform], if omitted or false no platform and no position information per vehicle will be returned, may be empty
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly includePosition?: boolean;

  /**
   * include amenities [Ausstatungsmerkmale] like WC, WLAN, boarding aids etc. on a vehicle base, if omitted or false no amenities will be returned
   * @type {boolean}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly includeAmenities?: boolean;

  /**
   * include (detailed) occupancy [Auslastung] for vehicles at departure, if omitted or NONE no occupancy will be returned - NONE (return no occupancy) - OVERALL (return only overall occupancy on a first / economy class level) - DETAIL (return detailed occupancy information like free bike mounts , free seats, stance etc.)
   * @type {OccupancyDetail}
   * @memberof TransportsApiVehicleSequenceDepartureUnmatched
   */
  readonly includeOccupancy?: OccupancyDetail;
}

/**
 * TransportsApi - object-oriented interface
 * @export
 * @class TransportsApi
 * @extends {BaseAPI}
 */
export class TransportsApi extends BaseAPI {
  /**
   * Returns all journeys [Fahrten] that contain a vehicle [Fahrzeug] with a matching vehicle id order by scheduled deparute time asc. May contain outdated and / or future journeys.
   * @param {TransportsApiMatchingVehicleIDRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportsApi
   */
  public matchingVehicleID(
    requestParameters: TransportsApiMatchingVehicleIDRequest,
    options?: AxiosRequestConfig,
  ) {
    return TransportsApiFp(this.configuration)
      .matchingVehicleID(
        requestParameters.vehicleID,
        requestParameters.date,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all administrations [Verwaltungen] that provide vehicle sequences [Wagenreihungen].
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportsApi
   */
  public vehicleSequenceAdministrations(options?: AxiosRequestConfig) {
    return TransportsApiFp(this.configuration)
      .vehicleSequenceAdministrations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
   * @param {TransportsApiVehicleSequenceArrivalUnmatchedRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportsApi
   */
  public vehicleSequenceArrivalUnmatched(
    requestParameters: TransportsApiVehicleSequenceArrivalUnmatchedRequest,
    options?: AxiosRequestConfig,
  ) {
    return TransportsApiFp(this.configuration)
      .vehicleSequenceArrivalUnmatched(
        requestParameters.date,
        requestParameters.category,
        requestParameters.number,
        requestParameters.evaNumber,
        requestParameters.time,
        requestParameters.includePosition,
        requestParameters.includeAmenities,
        requestParameters.includeOccupancy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmalen] and occupancy [Auslastung] for a particular departure.
   * @param {TransportsApiVehicleSequenceDepartureRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportsApi
   */
  public vehicleSequenceDeparture(
    requestParameters: TransportsApiVehicleSequenceDepartureRequest,
    options?: AxiosRequestConfig,
  ) {
    return TransportsApiFp(this.configuration)
      .vehicleSequenceDeparture(
        requestParameters.journeyID,
        requestParameters.departureID,
        requestParameters.includePosition,
        requestParameters.includeAmenities,
        requestParameters.includeOccupancy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transports vehicle sequence [Wagenreihung] with optional position at platform [Positionierung am Gleis], amenities [Ausstattungsmerkmale] and occupancy [Auslastung] for a particular departure. This is the unmatched entrypoint in case the caller is not aware of the particular journeyID and departureID.
   * @param {TransportsApiVehicleSequenceDepartureUnmatchedRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportsApi
   */
  public vehicleSequenceDepartureUnmatched(
    requestParameters: TransportsApiVehicleSequenceDepartureUnmatchedRequest,
    options?: AxiosRequestConfig,
  ) {
    return TransportsApiFp(this.configuration)
      .vehicleSequenceDepartureUnmatched(
        requestParameters.date,
        requestParameters.category,
        requestParameters.number,
        requestParameters.evaNumber,
        requestParameters.time,
        requestParameters.includePosition,
        requestParameters.includeAmenities,
        requestParameters.includeOccupancy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
