// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * RIS::Stations
 * ## Info  * member of the **RIS-API** family  ## Capabilities  ### Stations  Information on stations [Bahnhöfe] from DB Station & Service and DB Regio like:  * name, address, category [Bahnhofskategorie], owner [Betreiber / Verwaltung], country, timezone and geo coordinate * region information the station belongs [Regionalbereich] * available local services [bahnhofsnahe Dienstleistungen] at station  ### Stop Places  Information on a huge amount of stop-places [Haltestellen] coming from different source like EFZ [Europäisches Fahrplanzentrum] and DB Station & Service. The service offers therefore all stop-place that are part or that were part of the official sales time table for germany including foreign stop-places for transports driving into germany / leaving germany and connecting journeys in foreign countries that are part of the rail team alliance. ÖPNV stop-places are returned as well.  Brief information for particular stop-place like  * language dependent short, long, speech and symbol names from different sources [EFZ or BHW] * metropolis information [Metropole] * parent station [Bahnhof] * geo coordinates, country and timezone * transport types [Verkehrsmittel / Produktart] that depart / arrive * foreign key mappings [Fremdschlüssel] like EVA, RL100 / DS100, EPA, IBNR, DHID / IFOPT, STADA, EBHF, PLC and UIC * validity ranges [Gültigkeitsbereiche]  Different query options for stop-places like  * by name query with fuzzy-search [fehlertolerante Suche] and order by relevance [gewichtete Suche] and optional grouping by station [Bahnhof] in case stop-places belong to a station * by geo-coordinate and radius ordered by distance * by foreign key  Multiple groups a stop-place may belong to like  * Station [selber Bahnhof] * Sales [vertrieblicher Umsteigebereich inkl. ÖPNV]s * Metropolitan Area [Stadtgebiet]  ### Platforms  General information on platforms [Gleise, Bussteige, Plattformen etc.] for a particular stop-place like:  * name, start and end in meters, linked platforms [selber Bahnsteig], parent platform [für Teilgleise]s * sectors with name, start and end in meters, cube position [Würfelposition] and information ob cube signage [Beschilderung] * accessibility information [Barrierefreier Zugang] like audible signals, automatic doors, stair markings and a lot more * information on operational platforms [Betriebsgleise], optics [Optiken], reference points [Referenzpunkte] and orientations [Orientierung gemäß Nullpunkt]  ### Connecting-Times  Connecting-times [Umsteigezeiten / Anschlusszeiten] for a stop-place [Haltestelle] and all members of stop-place group [Umsteigebereich] including foreign stop-places [Auslandshalte gemäß Railteam-Flag etc.]:  * for different kind of stop-place groups     * Station [selber Bahnhof]     * Sales [vertrieblicher Umsteigebereich inkl. ÖPNV]     * All [alle Umsteigebereiche] supported * and different personae, if available     * Occasional Traveller [Gelegenheitsreisender]     * Frequent Traveller [Pendler]     * Handicapped Traveller [Mobilitätseingeschränkter Reisender] * from various sources     * RIL420 [Konzernrichtlinie]     * EFZ [Europäisches Fahrplanzentrum inkl. ÖPNV & Auslandshalte]     * IndoorRouting [Indoor Routing RIS-Maps] available  ### Local Services  Information about Travel-Center, Triple-S-Center [3S Zentrale],Railway Mission[Bahnhofsmission] and many more available by position or station.  ### Station Equipments  Detailed information about equipment at the train station such as:  * Locker with payment types, size, fee and many more. * **stay tuned*  ## Limitations  * *[backlog]* support active and inactive versions of stop-places/stations (differing date ranges) * *[backlog]* raise stop-place change events with RIS::Events in case stop-place data changes * *[backlog]* include Station & Service Bahnhofswissen with it\'s fully functional API starting from ~Q4 2021
 *
 * The version of the OpenAPI document: 1.10.0
 * Contact: doServices.Titan.Support@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 * Accessibility [Barrierefreiheit] information for a particular platform.
 * @export
 * @interface Accessibility
 */
export interface Accessibility {
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  audibleSignalsAvailable?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  automaticDoor?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  boardingAid?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  passengerInformationDisplay?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  platformSign?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  stairsMarking?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  standardPlatformHeight?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  stepFreeAccess?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactileGuidingStrips?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactileHandrailLabel?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactilePlatformAccess?: AccessibilityStatus;
}
/**
 * Status of platform accessibility [Barrierefreiheit] information. - AVAILABLE (accessibility item is available) - NOT_AVAILABLE (accessibility item is not available) - PARTIAL (accessibility item is only partial available, for instance available for 12a but not for 12b and therefore not for 12 in total) - NOT_APPLICABLE (accessibility item is not applicable because it depends on availability of other items, for instance stair mark depends on step free access) - UNKNOWN (no information on availability for accessibility item)
 * @export
 * @enum {string}
 */

export const AccessibilityStatus = {
  Available: 'AVAILABLE',
  NotAvailable: 'NOT_AVAILABLE',
  Partial: 'PARTIAL',
  NotApplicable: 'NOT_APPLICABLE',
  Unknown: 'UNKNOWN',
} as const;

export type AccessibilityStatus =
  (typeof AccessibilityStatus)[keyof typeof AccessibilityStatus];

/**
 * Address information with www info.
 * @export
 * @interface AddressWithWeb
 */
export interface AddressWithWeb {
  /**
   * Additional information [Addresszusatz] for this address, like for instance \'Hinterm Haus links\'.
   * @type {string}
   * @memberof AddressWithWeb
   */
  additionalInformation?: string;
  /**
   * City of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  city?: string;
  /**
   * Country of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  country?: string;
  /**
   * House-number of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  houseNumber?: string;
  /**
   * Postalcode [Postleitzahl] of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  postalCode?: string;
  /**
   * State of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  state?: string;
  /**
   * Street name of address the position should be retrieved for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  street?: string;
  /**
   * Web site for address.
   * @type {string}
   * @memberof AddressWithWeb
   */
  website?: string;
}
/**
 * Connecting time [Umsteigezeit] from a particular stop place [Haltestelle], platform [Gleis, Bahnsteig, Plattform] and optional sector [Gleisabschnitt, Steigabschnitt] to a particular station, platform and optional sector.
 * @export
 * @interface ConnectingTime
 */
export interface ConnectingTime {
  /**
   * Eva number of stop place [Haltestelle] to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromEvaNumber: string;
  /**
   * Platform [Gleis, Bahnsteig, Plattform] of stop place to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromPlatform?: string;
  /**
   * Sector [Gleisabschnitt, Steigabschnitt] of stop place to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromSector?: string;
  /**
   * Indicates whether connection takes place on the same physical platform [Bahnsteig] (platform \'12\' and \'13\' belong to physical platform \'12/13\' for instance).
   * @type {boolean}
   * @memberof ConnectingTime
   */
  identicalPhysicalPlatform: boolean;
  /**
   *
   * @type {ConnectingTimeSource}
   * @memberof ConnectingTime
   */
  source: ConnectingTimeSource;
  /**
   * Connecting times fo different personae.
   * @type {Array<ConnectionTime>}
   * @memberof ConnectingTime
   */
  times: Array<ConnectionTime>;
  /**
   * Eva number stop place to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toEvaNumber: string;
  /**
   * Platform [Gleis, Bahnsteig, Plattform] of stop place [Haltestelle] to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toPlatform?: string;
  /**
   * Sector [Gleisabschnitt, Steigabschnitt] of stop place [Haltestelle] to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toSector?: string;
}
/**
 * Possible groups to consider when returning connecting-times for particular stop-place. - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. ÖPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
 * @export
 * @enum {string}
 */

export const ConnectingTimeGroup = {
  Station: 'STATION',
  Sales: 'SALES',
  All: 'ALL',
} as const;

export type ConnectingTimeGroup =
  (typeof ConnectingTimeGroup)[keyof typeof ConnectingTimeGroup];

/**
 * Enumerates all possible sources for connecting times [Umsteigezeiten]. - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ = Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
 * @export
 * @enum {string}
 */

export const ConnectingTimeSource = {
  Ril420: 'RIL420',
  Efz: 'EFZ',
  IndoorRouting: 'INDOOR_ROUTING',
} as const;

export type ConnectingTimeSource =
  (typeof ConnectingTimeSource)[keyof typeof ConnectingTimeSource];

/**
 * Enumerates all possible sources to filter connecting times [Umsteigezeiten] for. - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ = Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
 * @export
 * @enum {string}
 */

export const ConnectingTimeSourceFilter = {
  Ril420: 'RIL420',
  Efz: 'EFZ',
  IndoorRouting: 'INDOOR_ROUTING',
} as const;

export type ConnectingTimeSourceFilter =
  (typeof ConnectingTimeSourceFilter)[keyof typeof ConnectingTimeSourceFilter];

/**
 * List of connecting times [Umsteigezeiten] for requested list of stop-places [Haltestellen].
 * @export
 * @interface ConnectingTimesBatch
 */
export interface ConnectingTimesBatch {
  /**
   * List of connecting times.
   * @type {Array<ConnectingTime>}
   * @memberof ConnectingTimesBatch
   */
  connectingTimesList: Array<ConnectingTime>;
}
/**
 * Connecting time [Umsteigezeit] for a particular combination of stop-places, platforms and sectors.
 * @export
 * @interface ConnectingTimesSingle
 */
export interface ConnectingTimesSingle {
  /**
   *
   * @type {ConnectingTime}
   * @memberof ConnectingTimesSingle
   */
  connectingTime?: ConnectingTime;
  /**
   * Fallback times for different personae in case no information is available.
   * @type {Array<ConnectionTimeFallback>}
   * @memberof ConnectingTimesSingle
   */
  fallbackTimes: Array<ConnectionTimeFallback>;
}
/**
 * Connection time [Anschlusszeit] for persona.
 * @export
 * @interface ConnectionTime
 */
export interface ConnectionTime {
  /**
   * Distance in meters.
   * @type {number}
   * @memberof ConnectionTime
   */
  distance?: number;
  /**
   * Duration of connect in ISO8601 (for instance \'P3Y6M4DT12H30M17S\').
   * @type {string}
   * @memberof ConnectionTime
   */
  duration: string;
  /**
   *
   * @type {PersonaType}
   * @memberof ConnectionTime
   */
  persona: PersonaType;
}
/**
 * Fallback connection time [Anschlusszeit] for persona in case no information on stop-places and or plattform is available.
 * @export
 * @interface ConnectionTimeFallback
 */
export interface ConnectionTimeFallback {
  /**
   * Duration of connect in ISO8601 (for instance \'P3Y6M4DT12H30M17S\').
   * @type {string}
   * @memberof ConnectionTimeFallback
   */
  duration: string;
  /**
   *
   * @type {PersonaType}
   * @memberof ConnectionTimeFallback
   */
  persona: PersonaType;
  /**
   *
   * @type {ConnectingTimeSource}
   * @memberof ConnectionTimeFallback
   */
  source: ConnectingTimeSource;
}
/**
 * Contact details for public use.
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   * Name of a person.
   * @type {string}
   * @memberof Contact
   */
  contactPerson?: string;
  /**
   * EMail address in iso-format.
   * @type {string}
   * @memberof Contact
   */
  email?: string;
  /**
   * further details of contact.
   * @type {string}
   * @memberof Contact
   */
  furtherDetails?: string;
  /**
   * phone number of contact.
   * @type {Array<PhoneNumber>}
   * @memberof Contact
   */
  phoneNumbers?: Array<PhoneNumber>;
  /**
   * contact url.
   * @type {string}
   * @memberof Contact
   */
  url?: string;
}
/**
 * 2D coordinate within geo reference system.
 * @export
 * @interface Coordinate2D
 */
export interface Coordinate2D {
  /**
   * Latitude position in reference system.
   * @type {number}
   * @memberof Coordinate2D
   */
  latitude: number;
  /**
   * Longitude position in reference system.
   * @type {number}
   * @memberof Coordinate2D
   */
  longitude: number;
}
/**
 * Locker [Schließfächer] equipments of a station [Bahnhof] search result. Take care that one particular equipment id may result in multiple lockers.
 * @export
 * @interface EquipmentLocker
 */
export interface EquipmentLocker {
  /**
   * Unique id of a locker equipment.
   * @type {string}
   * @memberof EquipmentLocker
   */
  equipmentID: string;
  /**
   * Lockers that are provided for this equipment id. (explanation: one locker rack may have one equipment id but may contain multiple lockers.)
   * @type {Array<Locker>}
   * @memberof EquipmentLocker
   */
  lockers: Array<Locker>;
  /**
   * Unique id of station [Bahnhof], usually the STADA for S&S owned stations.
   * @type {string}
   * @memberof EquipmentLocker
   */
  stationID: string;
}
/**
 * Enumerates all identifiers a locker [Schließfach] equipment of a particular station [Bahnhof] can be mapped into or mapped from. - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&S owned stations)
 * @export
 * @enum {string}
 */

export const EquipmentLockerKeyType = {
  Eva: 'EVA',
  StationId: 'STATION_ID',
} as const;

export type EquipmentLockerKeyType =
  (typeof EquipmentLockerKeyType)[keyof typeof EquipmentLockerKeyType];

/**
 * Locker [Schließfächer] equipments of a station [Bahnhof] search result.
 * @export
 * @interface EquipmentLockers
 */
export interface EquipmentLockers {
  /**
   * List of lockers [Schließfach] that matched the search result.
   * @type {Array<EquipmentLocker>}
   * @memberof EquipmentLockers
   */
  lockerList: Array<EquipmentLocker>;
}
/**
 * Detailed error information on field level.
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorDetail
   */
  detail: string;
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorDetail
   */
  errorCode?: number;
  /**
   * Name of field / element that raised the error.
   * @type {string}
   * @memberof ErrorDetail
   */
  field: string;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorDetail
   */
  title: string;
}
/**
 * API error object conforming to RFC7807.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   * Detailed information for error.
   * @type {string}
   * @memberof ErrorResponse
   */
  detail: string;
  /**
   * Unique code that identifies error.
   * @type {number}
   * @memberof ErrorResponse
   */
  errorCode?: number;
  /**
   * List of detailed errors in case multiple errors have lead to the surrounding error.
   * @type {Array<ErrorDetail>}
   * @memberof ErrorResponse
   */
  errors?: Array<ErrorDetail>;
  /**
   * Unique identifier for instance that raised the error.
   * @type {string}
   * @memberof ErrorResponse
   */
  instanceId?: string;
  /**
   * Http status for error origin.
   * @type {number}
   * @memberof ErrorResponse
   */
  status?: number;
  /**
   * Common description of error.
   * @type {string}
   * @memberof ErrorResponse
   */
  title: string;
}
/**
 * Information on local service [Bahnhofsnahe Dienstleistungen].
 * @export
 * @interface LocalService
 */
export interface LocalService {
  /**
   *
   * @type {AddressWithWeb}
   * @memberof LocalService
   */
  address?: AddressWithWeb;
  /**
   *
   * @type {Contact}
   * @memberof LocalService
   */
  contact?: Contact;
  /**
   * Description of the local service.
   * @type {string}
   * @memberof LocalService
   */
  description?: string;
  /**
   * ID of the local service for external usage.
   * @type {string}
   * @memberof LocalService
   */
  externalID?: string;
  /**
   * Unique id of the local service [Bahnhofsnahe Dienstleistungen].
   * @type {string}
   * @memberof LocalService
   */
  localServiceID: string;
  /**
   * Name of the local service.
   * @type {string}
   * @memberof LocalService
   */
  name?: string;
  /**
   * Opening times for local-service in OSM notation (see https://wiki.openstreetmap.org/wiki/DE:Key:opening_hours).
   * @type {string}
   * @memberof LocalService
   */
  openingHours?: string;
  /**
   *
   * @type {Coordinate2D}
   * @memberof LocalService
   */
  position?: Coordinate2D;
  /**
   * Unique id of station [Bahnhof], usually the STADA for S&S owned stations.
   * @type {string}
   * @memberof LocalService
   */
  stationID: string;
  /**
   * Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit & Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
   * @type {string}
   * @memberof LocalService
   */
  type: string;
  /**
   * Date the local service is valid from.
   * @type {string}
   * @memberof LocalService
   */
  validFrom?: string;
  /**
   * Date the local service is valid to.
   * @type {string}
   * @memberof LocalService
   */
  validTo?: string;
}
/**
 * Enumerates all identifiers a travel-center [Reisezentrum] can be mapped into or mapped from. - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&S owned stations)
 * @export
 * @enum {string}
 */

export const LocalServiceKeyType = {
  Eva: 'EVA',
  StationId: 'STATION_ID',
} as const;

export type LocalServiceKeyType =
  (typeof LocalServiceKeyType)[keyof typeof LocalServiceKeyType];

/**
 * List of local services [Bahnhofsnahe Dienstleistungen].
 * @export
 * @interface LocalServices
 */
export interface LocalServices {
  /**
   * List of local services.
   * @type {Array<LocalService>}
   * @memberof LocalServices
   */
  localServices: Array<LocalService>;
}
/**
 * Cursoring local-services [Bahnhofsnahe Dienstleistungen] search result.
 * @export
 * @interface LocalServicesCursoring
 */
export interface LocalServicesCursoring {
  /**
   * Value for the next page.
   * @type {string}
   * @memberof LocalServicesCursoring
   */
  after?: string;
  /**
   * Value for the previous page.
   * @type {string}
   * @memberof LocalServicesCursoring
   */
  before?: string;
  /**
   * List of local-services.
   * @type {Array<LocalService>}
   * @memberof LocalServicesCursoring
   */
  localServices: Array<LocalService>;
  /**
   * Total number of items.
   * @type {number}
   * @memberof LocalServicesCursoring
   */
  total: number;
}
/**
 * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)
 * @export
 * @enum {string}
 */

export const Locale = {
  De: 'DE',
  En: 'EN',
  Fr: 'FR',
  It: 'IT',
} as const;

export type Locale = (typeof Locale)[keyof typeof Locale];

/**
 * Locker [Schließfach] equipment of a particular station [Bahnhof].
 * @export
 * @interface Locker
 */
export interface Locker {
  /**
   * Amount of units of the locker.
   * @type {number}
   * @memberof Locker
   */
  amount: number;
  /**
   *
   * @type {LockerDimension}
   * @memberof Locker
   */
  dimension?: LockerDimension;
  /**
   *
   * @type {LockerFee}
   * @memberof Locker
   */
  fee?: LockerFee;
  /**
   * Maximum lease duration [Mietdauer] for use of a single unit of the locker in ISO8601 (for instance \'P3Y6M4DT12H30M17S\').
   * @type {string}
   * @memberof Locker
   */
  maxLeaseDuration?: string;
  /**
   * Supported payment types for locker usage. Possible values are: - CASH (cash payment available) - CASHLESS (other payment options than cash available)
   * @type {Array<string>}
   * @memberof Locker
   */
  paymentTypes: Array<string>;
  /**
   * Size of the locker. Possible values are: - SMALL - MEDIUM - LARGE - JUMBO
   * @type {string}
   * @memberof Locker
   */
  size: string;
}
/**
 * Dimension [Ausmaße] for lockers [Schließfächer].
 * @export
 * @interface LockerDimension
 */
export interface LockerDimension {
  /**
   * Locker depth of a single unit in mm of the locker.
   * @type {number}
   * @memberof LockerDimension
   */
  depth: number;
  /**
   * Locker height of a single unit in mm of the locker.
   * @type {number}
   * @memberof LockerDimension
   */
  height: number;
  /**
   * Locker width of a single unit in mm of the locker.
   * @type {number}
   * @memberof LockerDimension
   */
  width: number;
}
/**
 * Fee [Mietgebühr] for leasing lockers [Schließfächer].
 * @export
 * @interface LockerFee
 */
export interface LockerFee {
  /**
   * Fee for locker usage in cents (currency is EUR). Refers to fee period.
   * @type {number}
   * @memberof LockerFee
   */
  fee: number;
  /**
   * Period the refers to. Possible values are: - PER_MAX_LEASE_DURATION (fee must be payed per max lease duration) - PER_HOUR (fee must be payed per hour) - PER_DAY (fee must be payed per day)
   * @type {string}
   * @memberof LockerFee
   */
  feePeriod: string;
}
/**
 * Detailed operational [Betrieb] information.
 * @export
 * @interface Operational
 */
export interface Operational {
  /**
   * Total length of platform [Baulicher Bereich].
   * @type {number}
   * @memberof Operational
   */
  length?: number;
  /**
   * Names of the network platforms [Netzgleis] that belong to the platform.
   * @type {Array<string>}
   * @memberof Operational
   */
  networkPlatforms?: Array<string>;
  /**
   * Names of the operational units [Optiken] that belong to the platform.
   * @type {Array<string>}
   * @memberof Operational
   */
  optics?: Array<string>;
  /**
   * Orientation of the platform in degrees (north=0, east=90, ...), seen from the origin of the local coordinates.
   * @type {number}
   * @memberof Operational
   */
  orientation?: number;
  /**
   * Positions of the reference points that determine the position of a stopping train at the platform.
   * @type {Array<ReferencePoint>}
   * @memberof Operational
   */
  referencePoints?: Array<ReferencePoint>;
}
/**
 * Specifies different personae. - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
 * @export
 * @enum {string}
 */

export const PersonaType = {
  Handicapped: 'HANDICAPPED',
  OccasionalTraveller: 'OCCASIONAL_TRAVELLER',
  FrequentTraveller: 'FREQUENT_TRAVELLER',
} as const;

export type PersonaType = (typeof PersonaType)[keyof typeof PersonaType];

/**
 * a phone number.
 * @export
 * @interface PhoneNumber
 */
export interface PhoneNumber {
  /**
   * phone number of contact.
   * @type {string}
   * @memberof PhoneNumber
   */
  number: string;
  /**
   *
   * @type {PhoneNumberType}
   * @memberof PhoneNumber
   */
  type: PhoneNumberType;
}
/**
 * Enumerates all phone types.
 * @export
 * @enum {string}
 */

export const PhoneNumberType = {
  Business: 'BUSINESS',
  Mobile: 'MOBILE',
  Fax: 'FAX',
} as const;

export type PhoneNumberType =
  (typeof PhoneNumberType)[keyof typeof PhoneNumberType];

/**
 * Platform [Gleis, Bahnsteig, Plattform] information. All ranges and positions of objects are given in meter in local coordinates, e.g. as a distance to a fixed point somewhere on the platform and differentiating between the two possible directions by a plus- and a minus-sign.
 * @export
 * @interface Platform
 */
export interface Platform {
  /**
   *
   * @type {Accessibility}
   * @memberof Platform
   */
  accessibility?: Accessibility;
  /**
   * End of the usable part of the platform given in meter in local coordinates.
   * @type {number}
   * @memberof Platform
   */
  end?: number;
  /**
   * Indicates whether platform is a head platform [Kopfgleis].
   * @type {boolean}
   * @memberof Platform
   */
  headPlatform?: boolean;
  /**
   * IFOPT (transmodel identifier for fixed objects, in germany DHID = Deutschlandweite Halt ID also known as global id) of the platform [Gleis] (for instance \'de:06412:10:17:18\').
   * @type {string}
   * @memberof Platform
   */
  ifopt?: string;
  /**
   * Total length of platform [Baulicher Bereich].
   * @type {number}
   * @memberof Platform
   */
  length?: number;
  /**
   * List of platforms [Gleise] that share the same physical platform [Bahnsteig].
   * @type {Array<string>}
   * @memberof Platform
   */
  linkedPlatforms?: Array<string>;
  /**
   * Name of the platform (12, 1a, Nord, Süd etc.).
   * @type {string}
   * @memberof Platform
   */
  name: string;
  /**
   *
   * @type {Operational}
   * @memberof Platform
   */
  operational?: Operational;
  /**
   * Name of parent platform in case this is a sub platform [Teilgleis].
   * @type {string}
   * @memberof Platform
   */
  parentPlatform?: string;
  /**
   * List of sectors [Sektoren] that belong to the platform.
   * @type {Array<Sector>}
   * @memberof Platform
   */
  sectors?: Array<Sector>;
  /**
   * Start of the usable part of the platform given in meter in local coordinates. This value may differ from zero and may be positive as well as negative.
   * @type {number}
   * @memberof Platform
   */
  start?: number;
}
/**
 * List of platforms [Gleise, Bahnsteige, Plattformen] for a station.
 * @export
 * @interface Platforms
 */
export interface Platforms {
  /**
   * List of platforms.
   * @type {Array<Platform>}
   * @memberof Platforms
   */
  platforms: Array<Platform>;
}
/**
 * Reference point that indicates where a vehicle [Fahrzeug] stops at a platform [Gleis, Bahnsteig, Plattform].
 * @export
 * @interface ReferencePoint
 */
export interface ReferencePoint {
  /**
   * Length up to the reference point is to be used by a stopping formation.
   * @type {number}
   * @memberof ReferencePoint
   */
  maxLength?: number;
  /**
   * Name of the reference point.
   * @type {string}
   * @memberof ReferencePoint
   */
  name: string;
  /**
   * Position of the reference point in meter in local coordinates.
   * @type {number}
   * @memberof ReferencePoint
   */
  position: number;
  /**
   * Determines the direction the reference point is to be used. If true, the formation moves from origin to positive values in local coordinates.
   * @type {boolean}
   * @memberof ReferencePoint
   */
  readableFromOrigin: boolean;
  /**
   *
   * @type {ReferencePointType}
   * @memberof ReferencePoint
   */
  referencePointType: ReferencePointType;
  /**
   * Unique ID of reference point.
   * @type {string}
   * @memberof ReferencePoint
   */
  uuid: string;
}
/**
 * Type of a reference point. - STOP_SIGNAL (Haltesignal) - STOP_BOARD (Haltetafel)
 * @export
 * @enum {string}
 */

export const ReferencePointType = {
  Signal: 'STOP_SIGNAL',
  Board: 'STOP_BOARD',
} as const;

export type ReferencePointType =
  (typeof ReferencePointType)[keyof typeof ReferencePointType];

/**
 * Platform [Gleis, Bahnsteig, Plattform] sector [Gleisabschnitt, Steigabschnitt] information.
 * @export
 * @interface Sector
 */
export interface Sector {
  /**
   * Position of the cube [Sektorwürfel] given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  cubePosition?: number;
  /**
   * Indicates whether cube [Sektorwürfel] has signage [Beschilderung] nor not.
   * @type {boolean}
   * @memberof Sector
   */
  cubeSignage?: boolean;
  /**
   * End of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  end: number;
  /**
   * Name of the sector [Sektor / Mast etc.].
   * @type {string}
   * @memberof Sector
   */
  name: string;
  /**
   * Start of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  start: number;
}
/**
 * Base information for a station [Bahnhof].
 * @export
 * @interface Station
 */
export interface Station {
  /**
   *
   * @type {AddressWithWeb}
   * @memberof Station
   */
  address: AddressWithWeb;
  /**
   * Deprecated: Use for example \'/local-services/by-key?keyType=STATION_ID&key=1866\' to get all available local-services for Frankfurt Hbf. All local services [Bahnhofsnahe Dienstleistungen] that are available at the station. - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit & Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
   * @type {Array<string>}
   * @memberof Station
   * @deprecated
   */
  availableLocalServices: Array<string>;
  /**
   * Available transport types [Verkehrsarten] at station.
   * @type {Array<TransportType>}
   * @memberof Station
   */
  availableTransports: Array<TransportType>;
  /**
   * Country [Staat / Land] the station belongs to as ISO 3166-1 alpha-2 code [germany = \'DE\' for instance].
   * @type {string}
   * @memberof Station
   */
  countryCode: string;
  /**
   * Language dependent names for metropolis [Metropole].
   * @type {{ [key: string]: string; }}
   * @memberof Station
   */
  metropolis?: { [key: string]: string };
  /**
   * The municipality key [Amtlicher Gemeindeschlüssel (AGS)] the station belongs to. Only available for germany and may be empty.
   * @type {string}
   * @memberof Station
   */
  municipalityKey?: string;
  /**
   * Language dependent names for a station, may contain different station names for a specific language depending on names filter.
   * @type {{ [key: string]: StationName; }}
   * @memberof Station
   */
  names: { [key: string]: StationName };
  /**
   * Opening times for station in OSM notation (see https://wiki.openstreetmap.org/wiki/DE:Key:opening_hours).
   * @type {string}
   * @memberof Station
   */
  openingHours?: string;
  /**
   *
   * @type {StationOwner}
   * @memberof Station
   */
  owner: StationOwner;
  /**
   *
   * @type {Coordinate2D}
   * @memberof Station
   */
  position?: Coordinate2D;
  /**
   *
   * @type {StationRoofingType}
   * @memberof Station
   */
  roofing?: StationRoofingType;
  /**
   * The state code [Bundeslandkürzel] the station belongs to.
   * @type {string}
   * @memberof Station
   */
  state?: string;
  /**
   *
   * @type {StationCategory}
   * @memberof Station
   */
  stationCategory?: StationCategory;
  /**
   * Unique id of station [Bahnhof], usually the STADA for S&S owned stations.
   * @type {string}
   * @memberof Station
   */
  stationID: string;
  /**
   * Timezone the station belongs to, for instance \'Europe/Berlin\'. Must not necessarily be the time zone of the geo coordinate.
   * @type {string}
   * @memberof Station
   */
  timeZone: string;
  /**
   * Available transport associations [Verkehrsverbünde] at station.
   * @type {Array<string>}
   * @memberof Station
   */
  transportAssociations?: Array<string>;
  /**
   * Date the station is valid from.
   * @type {string}
   * @memberof Station
   */
  validFrom: string;
  /**
   * Date the station is valid to.
   * @type {string}
   * @memberof Station
   */
  validTo?: string;
}
/**
 * Category of station conforming to DB Station & Service..
 * @export
 * @enum {string}
 */

export const StationCategory = {
  _1: 'CATEGORY_1',
  _2: 'CATEGORY_2',
  _3: 'CATEGORY_3',
  _4: 'CATEGORY_4',
  _5: 'CATEGORY_5',
  _6: 'CATEGORY_6',
  _7: 'CATEGORY_7',
} as const;

export type StationCategory =
  (typeof StationCategory)[keyof typeof StationCategory];

/**
 * Name information for a station [Bahnhof].
 * @export
 * @interface StationName
 */
export interface StationName {
  /**
   * Name for station.
   * @type {string}
   * @memberof StationName
   */
  name: string;
}
/**
 * Organisational unit [Regionalbereich] information, usually from DB Netz.
 * @export
 * @interface StationOrganisationalUnit
 */
export interface StationOrganisationalUnit {
  /**
   * Number of organisational unit.
   * @type {number}
   * @memberof StationOrganisationalUnit
   */
  id: number;
  /**
   * Name of organisational unit.
   * @type {string}
   * @memberof StationOrganisationalUnit
   */
  name: string;
  /**
   * Short name of organisational unit, may be empty.
   * @type {string}
   * @memberof StationOrganisationalUnit
   */
  nameShort?: string;
}
/**
 * Base information for a stations [Bahnhof] owner [Eigentümer / Betreiber].
 * @export
 * @interface StationOwner
 */
export interface StationOwner {
  /**
   * Name of owner.
   * @type {string}
   * @memberof StationOwner
   */
  name: string;
  /**
   *
   * @type {StationOrganisationalUnit}
   * @memberof StationOwner
   */
  organisationalUnit?: StationOrganisationalUnit;
}
/**
 * Defines station roofing [Bahnhofsüberdachung]. - COVERED [überdacht] - PARTIALLY_COVERED [teilweise überdacht] - NOT_COVERED [nicht überdacht]
 * @export
 * @enum {string}
 */

export const StationRoofingType = {
  Covered: 'COVERED',
  PartiallyCovered: 'PARTIALLY_COVERED',
  NotCovered: 'NOT_COVERED',
} as const;

export type StationRoofingType =
  (typeof StationRoofingType)[keyof typeof StationRoofingType];

/**
 * Stations [Bahnhof] result.
 * @export
 * @interface Stations
 */
export interface Stations {
  /**
   * List of stations.
   * @type {Array<Station>}
   * @memberof Stations
   */
  stations: Array<Station>;
}
/**
 * Pageable stations search result.
 * @export
 * @interface StationsPageable
 */
export interface StationsPageable {
  /**
   * Maximum number of results that may be returned for one page, provided by the consumer.
   * @type {number}
   * @memberof StationsPageable
   */
  limit: number;
  /**
   * Pagination offset of the results, provided by the consumer.
   * @type {number}
   * @memberof StationsPageable
   */
  offset: number;
  /**
   * List of stations.
   * @type {Array<Station>}
   * @memberof StationsPageable
   */
  stations: Array<Station>;
  /**
   * Total number of available results.
   * @type {number}
   * @memberof StationsPageable
   */
  total: number;
}
/**
 * Base information for a stop-place [Haltestelle].
 * @export
 * @interface StopPlace
 */
export interface StopPlace {
  /**
   * Available transport types [Verkehrsarten] at stop place.
   * @type {Array<TransportType>}
   * @memberof StopPlace
   */
  availableTransports: Array<TransportType>;
  /**
   * Country [Staat / Land] the stop place belongs to as ISO 3166-1 alpha-2 code [germany = \'DE\' for instance].
   * @type {string}
   * @memberof StopPlace
   */
  countryCode: string;
  /**
   * Eva number of stop-place.
   * @type {string}
   * @memberof StopPlace
   */
  evaNumber: string;
  /**
   * Language dependent name for metropolis [Metropole].
   * @type {{ [key: string]: string; }}
   * @memberof StopPlace
   */
  metropolis?: { [key: string]: string };
  /**
   * The municipality key [Amtlicher Gemeindeschlüssel (AGS)] the stop place belongs to. Only available for germany and may be empty.
   * @type {string}
   * @memberof StopPlace
   */
  municipalityKey?: string;
  /**
   * Language dependent names for stop place, may contain different stop place names for a specific language depending on names filter.
   * @type {{ [key: string]: StopPlaceName; }}
   * @memberof StopPlace
   */
  names: { [key: string]: StopPlaceName };
  /**
   *
   * @type {Coordinate2D}
   * @memberof StopPlace
   */
  position?: Coordinate2D;
  /**
   * The state code [Bundeslandkürzel] the stop place belongs to.
   * @type {string}
   * @memberof StopPlace
   */
  state?: string;
  /**
   * ID of station [Bahnhof] the stop place belongs to [usually the STADA code for DB S&S], may be empty when stop place is not part of a station.
   * @type {string}
   * @memberof StopPlace
   */
  stationID?: string;
  /**
   * Timezone the stop place belongs to, for instance \'Europe/Berlin\'. Must not necessarily be the time zone of the geo coordinate.
   * @type {string}
   * @memberof StopPlace
   */
  timeZone: string;
  /**
   * Available transport associations [Verkehrsverbünde] at stop place.
   * @type {Array<string>}
   * @memberof StopPlace
   */
  transportAssociations?: Array<string>;
}
/**
 * Group for stop places [Haltestellen] with all group members.
 * @export
 * @interface StopPlaceGroup
 */
export interface StopPlaceGroup {
  /**
   * List of stop place ids [Eva-Number] that belong to the group.
   * @type {Array<string>}
   * @memberof StopPlaceGroup
   */
  members: Array<string>;
  /**
   *
   * @type {StopPlaceGroupType}
   * @memberof StopPlaceGroup
   */
  type: StopPlaceGroupType;
}
/**
 * Possible groups [Station] a set of stop places [Haltestellen] may belong to. - STATION (group defined by station, for instance FFM = Hoch + Tief, maintained by S&S STADA hierarchy) - SALES (group defined by sales [Vertrieb], for instance FFM = Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - METROPOLITAN_AREA (group defined by sales [Vertrieb], for instance Stadtgebiet FFM = all big stations within FFM, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum])
 * @export
 * @enum {string}
 */

export const StopPlaceGroupType = {
  Station: 'STATION',
  Sales: 'SALES',
  MetropolitanArea: 'METROPOLITAN_AREA',
} as const;

export type StopPlaceGroupType =
  (typeof StopPlaceGroupType)[keyof typeof StopPlaceGroupType];

/**
 * List of groups a stop place [Haltestelle] belongs to with all associated group members.
 * @export
 * @interface StopPlaceGroups
 */
export interface StopPlaceGroups {
  /**
   * List of groups the passed eva numbers belongs to including group members.
   * @type {Array<StopPlaceGroup>}
   * @memberof StopPlaceGroups
   */
  groups: Array<StopPlaceGroup>;
}
/**
 * Key mapping for a stop place [Haltestelle].
 * @export
 * @interface StopPlaceKey
 */
export interface StopPlaceKey {
  /**
   * Key value.
   * @type {string}
   * @memberof StopPlaceKey
   */
  key: string;
  /**
   *
   * @type {StopPlaceKeyType}
   * @memberof StopPlaceKey
   */
  type: StopPlaceKeyType;
}
/**
 * Enumerates all identifiers a stop-place [Haltestelle] can be mapped from. - IFOPT (Transmodel identifier for fixed objects, in germany DHID = Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa uic number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.]) - UIC (international station number) - PLC (primary location code)
 * @export
 * @enum {string}
 */

export const StopPlaceKeyFilter = {
  Ifopt: 'IFOPT',
  Eva: 'EVA',
  Rl100: 'RL100',
  Epa: 'EPA',
  Stada: 'STADA',
  Ibnr: 'IBNR',
  Ebhf: 'EBHF',
  Uic: 'UIC',
  Plc: 'PLC',
} as const;

export type StopPlaceKeyFilter =
  (typeof StopPlaceKeyFilter)[keyof typeof StopPlaceKeyFilter];

/**
 * Enumerates all identifiers a stop-place [Haltestelle] can be mapped into or mapped from. - IFOPT (Transmodel identifier for fixed objects, in germany DHID = Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary rl100 / ds100) - RL100_ALTERNATIVE (alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.]) - UIC (international station number) - PLC (primary location code)
 * @export
 * @enum {string}
 */

export const StopPlaceKeyType = {
  Ifopt: 'IFOPT',
  Eva: 'EVA',
  Rl100: 'RL100',
  Rl100Alternative: 'RL100_ALTERNATIVE',
  Epa: 'EPA',
  Stada: 'STADA',
  Ibnr: 'IBNR',
  Ebhf: 'EBHF',
  Uic: 'UIC',
  Plc: 'PLC',
} as const;

export type StopPlaceKeyType =
  (typeof StopPlaceKeyType)[keyof typeof StopPlaceKeyType];

/**
 * Different key mappings a stop place [Haltestelle] may have.
 * @export
 * @interface StopPlaceKeys
 */
export interface StopPlaceKeys {
  /**
   * List of stop place keys.
   * @type {Array<StopPlaceKey>}
   * @memberof StopPlaceKeys
   */
  keys: Array<StopPlaceKey>;
}
/**
 * Name information for stop place [Haltestelle].
 * @export
 * @interface StopPlaceName
 */
export interface StopPlaceName {
  /**
   * Name that is applicable for local areas, for instance \'Berlin Zoologischer Garten\' may become \'B Zoologischer Garten\'.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameLocal?: string;
  /**
   * Full long name for stop place.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameLong: string;
  /**
   * Short name (max. 20 characters) for stop place, if available.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameShort?: string;
  /**
   * Long name speech information for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  speechLong?: string;
  /**
   * Short name speech information for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  speechShort?: string;
  /**
   * Symbol information [UTF-8] for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  symbol?: string;
}
/**
 * Different grouping options for stop places name query. - STATION (group by parent station that is defined by DB Station & Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM = Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
 * @export
 * @enum {string}
 */

export const StopPlaceSearchGroupByKey = {
  Station: 'STATION',
  Sales: 'SALES',
  None: 'NONE',
} as const;

export type StopPlaceSearchGroupByKey =
  (typeof StopPlaceSearchGroupByKey)[keyof typeof StopPlaceSearchGroupByKey];

/**
 * Search result information for a stop place [Haltestelle].
 * @export
 * @interface StopPlaceSearchResult
 */
export interface StopPlaceSearchResult {
  /**
   * Available transport types [Verkehrsarten] at stop place.
   * @type {Array<TransportType>}
   * @memberof StopPlaceSearchResult
   */
  availableTransports: Array<TransportType>;
  /**
   * Eva number of stop place.
   * @type {string}
   * @memberof StopPlaceSearchResult
   */
  evaNumber: string;
  /**
   * TBD
   * @type {Array<string>}
   * @memberof StopPlaceSearchResult
   */
  groupMembers: Array<string>;
  /**
   * Language dependent names for stop place.
   * @type {{ [key: string]: StopPlaceName; }}
   * @memberof StopPlaceSearchResult
   */
  names: { [key: string]: StopPlaceName };
  /**
   *
   * @type {Coordinate2D}
   * @memberof StopPlaceSearchResult
   */
  position?: Coordinate2D;
  /**
   * ID of station [Bahnhof] the stop place belongs to [usually the STADA code for DB S&S], may be empty when stop place is not part of a station.
   * @type {string}
   * @memberof StopPlaceSearchResult
   */
  stationID?: string;
}
/**
 * Stop place [Haltestelle] search result.
 * @export
 * @interface StopPlaceSearchResults
 */
export interface StopPlaceSearchResults {
  /**
   * Stop places matching provided search criteria.
   * @type {Array<StopPlaceSearchResult>}
   * @memberof StopPlaceSearchResults
   */
  stopPlaces?: Array<StopPlaceSearchResult>;
}
/**
 * Different sorting keys for stop place queries. - RELEVANCE (stop places are sorted by relevance descending (central stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query descending)
 * @export
 * @enum {string}
 */

export const StopPlaceSortKey = {
  Relevance: 'RELEVANCE',
  QueryMatch: 'QUERY_MATCH',
} as const;

export type StopPlaceSortKey =
  (typeof StopPlaceSortKey)[keyof typeof StopPlaceSortKey];

/**
 * Stop place [Haltestelle] result.
 * @export
 * @interface StopPlaces
 */
export interface StopPlaces {
  /**
   * Stop places matching provided criteria.
   * @type {Array<StopPlace>}
   * @memberof StopPlaces
   */
  stopPlaces?: Array<StopPlace>;
}
/**
 * Type of transport. - HIGH_SPEED_TRAIN (High speed train [Hochgeschwindigkeitszug] like ICE or TGV etc.) - INTERCITY_TRAIN (Inter city train [Intercityzug]) - INTER_REGIONAL_TRAIN (Inter regional train [Interregiozug]) - REGIONAL_TRAIN (Regional train [Regionalzug]) - CITY_TRAIN (City train [S-Bahn]) - SUBWAY (Subway [U-Bahn]) - TRAM (Tram [Strassenbahn]) - BUS (Bus [Bus]) - FERRY (Ferry [Faehre]) - FLIGHT (Flight [Flugzeug]) - CAR (Car [Auto]) - TAXI (Taxi) - SHUTTLE (Shuttle [Ruftaxi]) - BIKE ((E-)Bike [Fahrrad]) - SCOOTER ((E-)Scooter [Roller]) - WALK (Walk ([Laufen]) - UNKNOWN (Unknown)
 * @export
 * @enum {string}
 */

export const TransportType = {
  HighSpeedTrain: 'HIGH_SPEED_TRAIN',
  IntercityTrain: 'INTERCITY_TRAIN',
  InterRegionalTrain: 'INTER_REGIONAL_TRAIN',
  RegionalTrain: 'REGIONAL_TRAIN',
  CityTrain: 'CITY_TRAIN',
  Subway: 'SUBWAY',
  Tram: 'TRAM',
  Bus: 'BUS',
  Ferry: 'FERRY',
  Flight: 'FLIGHT',
  Car: 'CAR',
  Taxi: 'TAXI',
  Shuttle: 'SHUTTLE',
  Bike: 'BIKE',
  Scooter: 'SCOOTER',
  Walk: 'WALK',
  Unknown: 'UNKNOWN',
} as const;

export type TransportType = (typeof TransportType)[keyof typeof TransportType];

/**
 * ConnectingTimesApi - axios parameter creator
 * @export
 */
export const ConnectingTimesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a particular connecting time [Umsteigezeiten] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platforms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectingTime: async (
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fromEvaNumber' is not null or undefined
      assertParamExists('getConnectingTime', 'fromEvaNumber', fromEvaNumber);
      // verify required parameter 'toEvaNumber' is not null or undefined
      assertParamExists('getConnectingTime', 'toEvaNumber', toEvaNumber);
      const localVarPath = `/connecting-times/{fromEvaNumber}/{toEvaNumber}`
        .replace(
          `{${'fromEvaNumber'}}`,
          encodeURIComponent(String(fromEvaNumber)),
        )
        .replace(`{${'toEvaNumber'}}`, encodeURIComponent(String(toEvaNumber)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (fromPlatform !== undefined) {
        localVarQueryParameter['fromPlatform'] = fromPlatform;
      }

      if (fromSector !== undefined) {
        localVarQueryParameter['fromSector'] = fromSector;
      }

      if (toPlatform !== undefined) {
        localVarQueryParameter['toPlatform'] = toPlatform;
      }

      if (toSector !== undefined) {
        localVarQueryParameter['toSector'] = toSector;
      }

      if (personaTypes) {
        localVarQueryParameter['personaTypes'] = personaTypes;
      }

      if (source) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. ÖPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned although the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectingTimes: async (
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getConnectingTimes', 'evaNumber', evaNumber);
      const localVarPath = `/connecting-times/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (calculateSectors !== undefined) {
        localVarQueryParameter['calculateSectors'] = calculateSectors;
      }

      if (personaTypes) {
        localVarQueryParameter['personaTypes'] = personaTypes;
      }

      if (source) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectingTimesApi - functional programming interface
 * @export
 */
export const ConnectingTimesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConnectingTimesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a particular connecting time [Umsteigezeiten] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platforms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectingTime(
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConnectingTimesSingle>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConnectingTime(
          fromEvaNumber,
          toEvaNumber,
          fromPlatform,
          fromSector,
          toPlatform,
          toSector,
          personaTypes,
          source,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. ÖPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned although the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectingTimes(
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConnectingTimesBatch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConnectingTimes(
          evaNumber,
          group,
          calculateSectors,
          personaTypes,
          source,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ConnectingTimesApi - factory interface
 * @export
 */
export const ConnectingTimesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConnectingTimesApiFp(configuration);
  return {
    /**
     * Returns a particular connecting time [Umsteigezeiten] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platforms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectingTime(
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options?: any,
    ): AxiosPromise<ConnectingTimesSingle> {
      return localVarFp
        .getConnectingTime(
          fromEvaNumber,
          toEvaNumber,
          fromPlatform,
          fromSector,
          toPlatform,
          toSector,
          personaTypes,
          source,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. ÖPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned although the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectingTimes(
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options?: any,
    ): AxiosPromise<ConnectingTimesBatch> {
      return localVarFp
        .getConnectingTimes(
          evaNumber,
          group,
          calculateSectors,
          personaTypes,
          source,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getConnectingTime operation in ConnectingTimesApi.
 * @export
 * @interface ConnectingTimesApiGetConnectingTimeRequest
 */
export interface ConnectingTimesApiGetConnectingTimeRequest {
  /**
   * eva number of desired origin stop place
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly fromEvaNumber: string;

  /**
   * eva number of desired destination stop place
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly toEvaNumber: string;

  /**
   * platform to calculate time origin, if omitted fallback structure will be used
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly fromPlatform?: string;

  /**
   * sector to calculate time origin, if omitted fallback is platform level
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly fromSector?: string;

  /**
   * platform to calculate time destination, if omitted fallback structure will be used
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly toPlatform?: string;

  /**
   * sector to calculate times destination, if omitted fallback is platform level
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly toSector?: string;

  /**
   * persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
   * @type {Array<PersonaType>}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly personaTypes?: Array<PersonaType>;

  /**
   * sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
   * @type {Array<ConnectingTimeSource>}
   * @memberof ConnectingTimesApiGetConnectingTime
   */
  readonly source?: Array<ConnectingTimeSource>;
}

/**
 * Request parameters for getConnectingTimes operation in ConnectingTimesApi.
 * @export
 * @interface ConnectingTimesApiGetConnectingTimesRequest
 */
export interface ConnectingTimesApiGetConnectingTimesRequest {
  /**
   * eva number of desired origin stop place
   * @type {string}
   * @memberof ConnectingTimesApiGetConnectingTimes
   */
  readonly evaNumber: string;

  /**
   * stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. ÖPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
   * @type {ConnectingTimeGroup}
   * @memberof ConnectingTimesApiGetConnectingTimes
   */
  readonly group?: ConnectingTimeGroup;

  /**
   * should connecting times be calculated based on sector level, otherwise platform level
   * @type {boolean}
   * @memberof ConnectingTimesApiGetConnectingTimes
   */
  readonly calculateSectors?: boolean;

  /**
   * persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicapped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
   * @type {Array<PersonaType>}
   * @memberof ConnectingTimesApiGetConnectingTimes
   */
  readonly personaTypes?: Array<PersonaType>;

  /**
   * sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned although the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
   * @type {Array<ConnectingTimeSourceFilter>}
   * @memberof ConnectingTimesApiGetConnectingTimes
   */
  readonly source?: Array<ConnectingTimeSourceFilter>;
}

/**
 * ConnectingTimesApi - object-oriented interface
 * @export
 * @class ConnectingTimesApi
 * @extends {BaseAPI}
 */
export class ConnectingTimesApi extends BaseAPI {
  /**
   * Returns a particular connecting time [Umsteigezeiten] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platforms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
   * @param {ConnectingTimesApiGetConnectingTimeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectingTimesApi
   */
  public getConnectingTime(
    requestParameters: ConnectingTimesApiGetConnectingTimeRequest,
    options?: AxiosRequestConfig,
  ) {
    return ConnectingTimesApiFp(this.configuration)
      .getConnectingTime(
        requestParameters.fromEvaNumber,
        requestParameters.toEvaNumber,
        requestParameters.fromPlatform,
        requestParameters.fromSector,
        requestParameters.toPlatform,
        requestParameters.toSector,
        requestParameters.personaTypes,
        requestParameters.source,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitalized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
   * @param {ConnectingTimesApiGetConnectingTimesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectingTimesApi
   */
  public getConnectingTimes(
    requestParameters: ConnectingTimesApiGetConnectingTimesRequest,
    options?: AxiosRequestConfig,
  ) {
    return ConnectingTimesApiFp(this.configuration)
      .getConnectingTimes(
        requestParameters.evaNumber,
        requestParameters.group,
        requestParameters.calculateSectors,
        requestParameters.personaTypes,
        requestParameters.source,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LocalServicesApi - axios parameter creator
 * @export
 */
export const LocalServicesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns details of a local-service [Bahnhofsnahe Dienstleistung] for requested ID.
     * @param {string} localServiceID id of desired local-service [Bahnhofsnahe Dienstleistung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalService: async (
      localServiceID: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'localServiceID' is not null or undefined
      assertParamExists('getLocalService', 'localServiceID', localServiceID);
      const localVarPath = `/local-services/{localServiceID}`.replace(
        `{${'localServiceID'}}`,
        encodeURIComponent(String(localServiceID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all local-services [Bahnhofsnahe Dienstleistungen].
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {string} [before] Cursor for retrieving the previous page in order to navigate through result list
     * @param {string} [after] Cursor for retrieving the next page in order to navigate through result list
     * @param {number} [limit] Limit total amount of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServices: async (
      types: Array<string>,
      before?: string,
      after?: string,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'types' is not null or undefined
      assertParamExists('getLocalServices', 'types', types);
      const localVarPath = `/local-services`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (before !== undefined) {
        localVarQueryParameter['before'] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter['after'] = after;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] that match the provided key.
     * @param {LocalServiceKeyType} keyType type of local-service key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return local-services [Bahnhofsnahe Dienstleistungen] for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServicesByKey: async (
      keyType: LocalServiceKeyType,
      key: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('getLocalServicesByKey', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('getLocalServicesByKey', 'key', key);
      const localVarPath = `/local-services/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] around geo position within provided radius ordered by distance asc.
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {number} latitude geo reference position latitude
     * @param {number} longitude geo reference position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServicesByPosition: async (
      types: Array<string>,
      latitude: number,
      longitude: number,
      radius?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'types' is not null or undefined
      assertParamExists('getLocalServicesByPosition', 'types', types);
      // verify required parameter 'latitude' is not null or undefined
      assertParamExists('getLocalServicesByPosition', 'latitude', latitude);
      // verify required parameter 'longitude' is not null or undefined
      assertParamExists('getLocalServicesByPosition', 'longitude', longitude);
      const localVarPath = `/local-services/by-position`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter['radius'] = radius;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LocalServicesApi - functional programming interface
 * @export
 */
export const LocalServicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LocalServicesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns details of a local-service [Bahnhofsnahe Dienstleistung] for requested ID.
     * @param {string} localServiceID id of desired local-service [Bahnhofsnahe Dienstleistung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalService(
      localServiceID: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalService>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLocalService(
        localServiceID,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all local-services [Bahnhofsnahe Dienstleistungen].
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {string} [before] Cursor for retrieving the previous page in order to navigate through result list
     * @param {string} [after] Cursor for retrieving the next page in order to navigate through result list
     * @param {number} [limit] Limit total amount of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalServices(
      types: Array<string>,
      before?: string,
      after?: string,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LocalServicesCursoring>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLocalServices(
          types,
          before,
          after,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] that match the provided key.
     * @param {LocalServiceKeyType} keyType type of local-service key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return local-services [Bahnhofsnahe Dienstleistungen] for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalServicesByKey(
      keyType: LocalServiceKeyType,
      key: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalServices>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLocalServicesByKey(
          keyType,
          key,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] around geo position within provided radius ordered by distance asc.
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {number} latitude geo reference position latitude
     * @param {number} longitude geo reference position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalServicesByPosition(
      types: Array<string>,
      latitude: number,
      longitude: number,
      radius?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalServices>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLocalServicesByPosition(
          types,
          latitude,
          longitude,
          radius,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LocalServicesApi - factory interface
 * @export
 */
export const LocalServicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LocalServicesApiFp(configuration);
  return {
    /**
     * Returns details of a local-service [Bahnhofsnahe Dienstleistung] for requested ID.
     * @param {string} localServiceID id of desired local-service [Bahnhofsnahe Dienstleistung]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalService(
      localServiceID: string,
      options?: any,
    ): AxiosPromise<LocalService> {
      return localVarFp
        .getLocalService(localServiceID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all local-services [Bahnhofsnahe Dienstleistungen].
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {string} [before] Cursor for retrieving the previous page in order to navigate through result list
     * @param {string} [after] Cursor for retrieving the next page in order to navigate through result list
     * @param {number} [limit] Limit total amount of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServices(
      types: Array<string>,
      before?: string,
      after?: string,
      limit?: number,
      options?: any,
    ): AxiosPromise<LocalServicesCursoring> {
      return localVarFp
        .getLocalServices(types, before, after, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] that match the provided key.
     * @param {LocalServiceKeyType} keyType type of local-service key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return local-services [Bahnhofsnahe Dienstleistungen] for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServicesByKey(
      keyType: LocalServiceKeyType,
      key: string,
      options?: any,
    ): AxiosPromise<LocalServices> {
      return localVarFp
        .getLocalServicesByKey(keyType, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] around geo position within provided radius ordered by distance asc.
     * @param {Array<string>} types Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
     * @param {number} latitude geo reference position latitude
     * @param {number} longitude geo reference position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalServicesByPosition(
      types: Array<string>,
      latitude: number,
      longitude: number,
      radius?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<LocalServices> {
      return localVarFp
        .getLocalServicesByPosition(
          types,
          latitude,
          longitude,
          radius,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getLocalService operation in LocalServicesApi.
 * @export
 * @interface LocalServicesApiGetLocalServiceRequest
 */
export interface LocalServicesApiGetLocalServiceRequest {
  /**
   * id of desired local-service [Bahnhofsnahe Dienstleistung]
   * @type {string}
   * @memberof LocalServicesApiGetLocalService
   */
  readonly localServiceID: string;
}

/**
 * Request parameters for getLocalServices operation in LocalServicesApi.
 * @export
 * @interface LocalServicesApiGetLocalServicesRequest
 */
export interface LocalServicesApiGetLocalServicesRequest {
  /**
   * Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
   * @type {Array<string>}
   * @memberof LocalServicesApiGetLocalServices
   */
  readonly types: Array<string>;

  /**
   * Cursor for retrieving the previous page in order to navigate through result list
   * @type {string}
   * @memberof LocalServicesApiGetLocalServices
   */
  readonly before?: string;

  /**
   * Cursor for retrieving the next page in order to navigate through result list
   * @type {string}
   * @memberof LocalServicesApiGetLocalServices
   */
  readonly after?: string;

  /**
   * Limit total amount of results
   * @type {number}
   * @memberof LocalServicesApiGetLocalServices
   */
  readonly limit?: number;
}

/**
 * Request parameters for getLocalServicesByKey operation in LocalServicesApi.
 * @export
 * @interface LocalServicesApiGetLocalServicesByKeyRequest
 */
export interface LocalServicesApiGetLocalServicesByKeyRequest {
  /**
   * type of local-service key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
   * @type {LocalServiceKeyType}
   * @memberof LocalServicesApiGetLocalServicesByKey
   */
  readonly keyType: LocalServiceKeyType;

  /**
   * key to return local-services [Bahnhofsnahe Dienstleistungen] for
   * @type {string}
   * @memberof LocalServicesApiGetLocalServicesByKey
   */
  readonly key: string;
}

/**
 * Request parameters for getLocalServicesByPosition operation in LocalServicesApi.
 * @export
 * @interface LocalServicesApiGetLocalServicesByPositionRequest
 */
export interface LocalServicesApiGetLocalServicesByPositionRequest {
  /**
   * Types of local service. Possible values are: - INFORMATION_COUNTER [Informationsstand für Belange im Bahnhof (kein Fahrkartenverkauf)] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [3S Zentrale für Service, Sicherheit &amp; Sauberkeit] - TRAVEL_LOUNGE [Lounge (DB Lounge z.B.)] - LOST_PROPERTY_OFFICE [Fundstelle] - RAILWAY_MISSION [Bahnhofsmission] - HANDICAPPED_TRAVELLER_SERVICE [Service für mobilitätseingeschränkte Reisende] - LOCKER [Schließfächer] - WIFI [WLan] - CAR_PARKING [Autoparkplatz, ggf. kostenpflichtig] - BICYCLE_PARKING [Fahrradparkplätze, ggf. kostenpflichtig] - PUBLIC_RESTROOM [Öffentliches WC, ggf. kostenpflichtig] - TRAVEL_NECESSITIES [Geschäft für den Reisendenbedarf] - CAR_RENTAL [Car-Sharer oder Mietwagen] - BICYCLE_RENTAL [Mieträder] - TAXI_RANK [Taxi Stand] - MOBILE_TRAVEL_SERVICE [Mobiler Service] - RAD_PLUS (Rad+ Gebiet)
   * @type {Array<string>}
   * @memberof LocalServicesApiGetLocalServicesByPosition
   */
  readonly types: Array<string>;

  /**
   * geo reference position latitude
   * @type {number}
   * @memberof LocalServicesApiGetLocalServicesByPosition
   */
  readonly latitude: number;

  /**
   * geo reference position longitude
   * @type {number}
   * @memberof LocalServicesApiGetLocalServicesByPosition
   */
  readonly longitude: number;

  /**
   * radius in meters around geo position
   * @type {number}
   * @memberof LocalServicesApiGetLocalServicesByPosition
   */
  readonly radius?: number;

  /**
   * limit parameter in order to limit total amount of results, if omitted no truncation applies
   * @type {number}
   * @memberof LocalServicesApiGetLocalServicesByPosition
   */
  readonly limit?: number;
}

/**
 * LocalServicesApi - object-oriented interface
 * @export
 * @class LocalServicesApi
 * @extends {BaseAPI}
 */
export class LocalServicesApi extends BaseAPI {
  /**
   * Returns details of a local-service [Bahnhofsnahe Dienstleistung] for requested ID.
   * @param {LocalServicesApiGetLocalServiceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocalServicesApi
   */
  public getLocalService(
    requestParameters: LocalServicesApiGetLocalServiceRequest,
    options?: AxiosRequestConfig,
  ) {
    return LocalServicesApiFp(this.configuration)
      .getLocalService(requestParameters.localServiceID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all local-services [Bahnhofsnahe Dienstleistungen].
   * @param {LocalServicesApiGetLocalServicesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocalServicesApi
   */
  public getLocalServices(
    requestParameters: LocalServicesApiGetLocalServicesRequest,
    options?: AxiosRequestConfig,
  ) {
    return LocalServicesApiFp(this.configuration)
      .getLocalServices(
        requestParameters.types,
        requestParameters.before,
        requestParameters.after,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] that match the provided key.
   * @param {LocalServicesApiGetLocalServicesByKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocalServicesApi
   */
  public getLocalServicesByKey(
    requestParameters: LocalServicesApiGetLocalServicesByKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return LocalServicesApiFp(this.configuration)
      .getLocalServicesByKey(
        requestParameters.keyType,
        requestParameters.key,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of local-services [Bahnhofsnahe Dienstleistungen] around geo position within provided radius ordered by distance asc.
   * @param {LocalServicesApiGetLocalServicesByPositionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocalServicesApi
   */
  public getLocalServicesByPosition(
    requestParameters: LocalServicesApiGetLocalServicesByPositionRequest,
    options?: AxiosRequestConfig,
  ) {
    return LocalServicesApiFp(this.configuration)
      .getLocalServicesByPosition(
        requestParameters.types,
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.radius,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatform: async (
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getPlatform', 'evaNumber', evaNumber);
      // verify required parameter 'platformName' is not null or undefined
      assertParamExists('getPlatform', 'platformName', platformName);
      const localVarPath = `/platforms/{evaNumber}/{platformName}`
        .replace(`{${'evaNumber'}}`, encodeURIComponent(String(evaNumber)))
        .replace(
          `{${'platformName'}}`,
          encodeURIComponent(String(platformName)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatforms: async (
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getPlatforms', 'evaNumber', evaNumber);
      const localVarPath = `/platforms/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      if (includeSubPlatforms !== undefined) {
        localVarQueryParameter['includeSubPlatforms'] = includeSubPlatforms;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of key the platforms belong to - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatformsByKey: async (
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('getPlatformsByKey', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('getPlatformsByKey', 'key', key);
      const localVarPath = `/platforms/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      if (includeSubPlatforms !== undefined) {
        localVarQueryParameter['includeSubPlatforms'] = includeSubPlatforms;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PlatformsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlatform(
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatform(
        evaNumber,
        platformName,
        includeSectors,
        includeAccessibility,
        includeOperational,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlatforms(
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platforms>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatforms(
        evaNumber,
        includeSectors,
        includeAccessibility,
        includeOperational,
        includeSubPlatforms,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of key the platforms belong to - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlatformsByKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platforms>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlatformsByKey(
          keyType,
          key,
          includeSectors,
          includeAccessibility,
          includeOperational,
          includeSubPlatforms,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PlatformsApiFp(configuration);
  return {
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatform(
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      options?: any,
    ): AxiosPromise<Platform> {
      return localVarFp
        .getPlatform(
          evaNumber,
          platformName,
          includeSectors,
          includeAccessibility,
          includeOperational,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatforms(
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options?: any,
    ): AxiosPromise<Platforms> {
      return localVarFp
        .getPlatforms(
          evaNumber,
          includeSectors,
          includeAccessibility,
          includeOperational,
          includeSubPlatforms,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of key the platforms belong to - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should sub platforms [Teilgleise] be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlatformsByKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      options?: any,
    ): AxiosPromise<Platforms> {
      return localVarFp
        .getPlatformsByKey(
          keyType,
          key,
          includeSectors,
          includeAccessibility,
          includeOperational,
          includeSubPlatforms,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPlatform operation in PlatformsApi.
 * @export
 * @interface PlatformsApiGetPlatformRequest
 */
export interface PlatformsApiGetPlatformRequest {
  /**
   * eva number of desired stop place [Haltestelle]
   * @type {string}
   * @memberof PlatformsApiGetPlatform
   */
  readonly evaNumber: string;

  /**
   * name of desired platform
   * @type {string}
   * @memberof PlatformsApiGetPlatform
   */
  readonly platformName: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatform
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatform
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatform
   */
  readonly includeOperational?: boolean;
}

/**
 * Request parameters for getPlatforms operation in PlatformsApi.
 * @export
 * @interface PlatformsApiGetPlatformsRequest
 */
export interface PlatformsApiGetPlatformsRequest {
  /**
   * eva number of desired stop place [Haltestelle]
   * @type {string}
   * @memberof PlatformsApiGetPlatforms
   */
  readonly evaNumber: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatforms
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatforms
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatforms
   */
  readonly includeOperational?: boolean;

  /**
   * should sub platforms [Teilgleise] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatforms
   */
  readonly includeSubPlatforms?: boolean;
}

/**
 * Request parameters for getPlatformsByKey operation in PlatformsApi.
 * @export
 * @interface PlatformsApiGetPlatformsByKeyRequest
 */
export interface PlatformsApiGetPlatformsByKeyRequest {
  /**
   * type of key the platforms belong to - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
   * @type {StopPlaceKeyFilter}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly keyType: StopPlaceKeyFilter;

  /**
   * key to return platforms for
   * @type {string}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly key: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly includeOperational?: boolean;

  /**
   * should sub platforms [Teilgleise] be included
   * @type {boolean}
   * @memberof PlatformsApiGetPlatformsByKey
   */
  readonly includeSubPlatforms?: boolean;
}

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
  /**
   * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
   * @param {PlatformsApiGetPlatformRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public getPlatform(
    requestParameters: PlatformsApiGetPlatformRequest,
    options?: AxiosRequestConfig,
  ) {
    return PlatformsApiFp(this.configuration)
      .getPlatform(
        requestParameters.evaNumber,
        requestParameters.platformName,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
   * @param {PlatformsApiGetPlatformsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public getPlatforms(
    requestParameters: PlatformsApiGetPlatformsRequest,
    options?: AxiosRequestConfig,
  ) {
    return PlatformsApiFp(this.configuration)
      .getPlatforms(
        requestParameters.evaNumber,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        requestParameters.includeSubPlatforms,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns platforms [Gleise, Plattformen] that match the provided key.
   * @param {PlatformsApiGetPlatformsByKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public getPlatformsByKey(
    requestParameters: PlatformsApiGetPlatformsByKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return PlatformsApiFp(this.configuration)
      .getPlatformsByKey(
        requestParameters.keyType,
        requestParameters.key,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        requestParameters.includeSubPlatforms,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StationEquipmentsApi - axios parameter creator
 * @export
 */
export const StationEquipmentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns details of a locker [Schließfächer] equipment for requested ID.
     * @param {string} lockerEquipmentID id of desired locker [Schließfach] equipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockerByEquipmentID: async (
      lockerEquipmentID: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'lockerEquipmentID' is not null or undefined
      assertParamExists(
        'getLockerByEquipmentID',
        'lockerEquipmentID',
        lockerEquipmentID,
      );
      const localVarPath =
        `/station-equipments/locker/{lockerEquipmentID}`.replace(
          `{${'lockerEquipmentID'}}`,
          encodeURIComponent(String(lockerEquipmentID)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of locker [Schließfächer] equipments that are associated with the provided key.
     * @param {EquipmentLockerKeyType} keyType type of associated locker equipment key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return locker equipments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockersByKey: async (
      keyType: EquipmentLockerKeyType,
      key: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('getLockersByKey', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('getLockersByKey', 'key', key);
      const localVarPath = `/station-equipments/locker/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StationEquipmentsApi - functional programming interface
 * @export
 */
export const StationEquipmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StationEquipmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns details of a locker [Schließfächer] equipment for requested ID.
     * @param {string} lockerEquipmentID id of desired locker [Schließfach] equipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLockerByEquipmentID(
      lockerEquipmentID: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EquipmentLocker>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLockerByEquipmentID(
          lockerEquipmentID,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of locker [Schließfächer] equipments that are associated with the provided key.
     * @param {EquipmentLockerKeyType} keyType type of associated locker equipment key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return locker equipments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLockersByKey(
      keyType: EquipmentLockerKeyType,
      key: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EquipmentLockers>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLockersByKey(
        keyType,
        key,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StationEquipmentsApi - factory interface
 * @export
 */
export const StationEquipmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StationEquipmentsApiFp(configuration);
  return {
    /**
     * Returns details of a locker [Schließfächer] equipment for requested ID.
     * @param {string} lockerEquipmentID id of desired locker [Schließfach] equipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockerByEquipmentID(
      lockerEquipmentID: string,
      options?: any,
    ): AxiosPromise<EquipmentLocker> {
      return localVarFp
        .getLockerByEquipmentID(lockerEquipmentID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of locker [Schließfächer] equipments that are associated with the provided key.
     * @param {EquipmentLockerKeyType} keyType type of associated locker equipment key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
     * @param {string} key key to return locker equipments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockersByKey(
      keyType: EquipmentLockerKeyType,
      key: string,
      options?: any,
    ): AxiosPromise<EquipmentLockers> {
      return localVarFp
        .getLockersByKey(keyType, key, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getLockerByEquipmentID operation in StationEquipmentsApi.
 * @export
 * @interface StationEquipmentsApiGetLockerByEquipmentIDRequest
 */
export interface StationEquipmentsApiGetLockerByEquipmentIDRequest {
  /**
   * id of desired locker [Schließfach] equipment
   * @type {string}
   * @memberof StationEquipmentsApiGetLockerByEquipmentID
   */
  readonly lockerEquipmentID: string;
}

/**
 * Request parameters for getLockersByKey operation in StationEquipmentsApi.
 * @export
 * @interface StationEquipmentsApiGetLockersByKeyRequest
 */
export interface StationEquipmentsApiGetLockersByKeyRequest {
  /**
   * type of associated locker equipment key - EVA (eva number of stop-place [Haltestelle]) - STATION_ID (id of the station [Bahnhof], usually the STADA for S&amp;S owned stations)
   * @type {EquipmentLockerKeyType}
   * @memberof StationEquipmentsApiGetLockersByKey
   */
  readonly keyType: EquipmentLockerKeyType;

  /**
   * key to return locker equipments for
   * @type {string}
   * @memberof StationEquipmentsApiGetLockersByKey
   */
  readonly key: string;
}

/**
 * StationEquipmentsApi - object-oriented interface
 * @export
 * @class StationEquipmentsApi
 * @extends {BaseAPI}
 */
export class StationEquipmentsApi extends BaseAPI {
  /**
   * Returns details of a locker [Schließfächer] equipment for requested ID.
   * @param {StationEquipmentsApiGetLockerByEquipmentIDRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationEquipmentsApi
   */
  public getLockerByEquipmentID(
    requestParameters: StationEquipmentsApiGetLockerByEquipmentIDRequest,
    options?: AxiosRequestConfig,
  ) {
    return StationEquipmentsApiFp(this.configuration)
      .getLockerByEquipmentID(requestParameters.lockerEquipmentID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of locker [Schließfächer] equipments that are associated with the provided key.
   * @param {StationEquipmentsApiGetLockersByKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationEquipmentsApi
   */
  public getLockersByKey(
    requestParameters: StationEquipmentsApiGetLockersByKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return StationEquipmentsApiFp(this.configuration)
      .getLockersByKey(
        requestParameters.keyType,
        requestParameters.key,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StationsApi - axios parameter creator
 * @export
 */
export const StationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStation: async (
      stationID: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('getStation', 'stationID', stationID);
      const localVarPath = `/stations/{stationID}`.replace(
        `{${'stationID'}}`,
        encodeURIComponent(String(stationID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all available stations [Bahnhöfe].
     * @param {string} [state] state [Bundesland] to limit search results for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStations: async (
      state?: string,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/stations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (lastChanged !== undefined) {
        localVarQueryParameter['lastChanged'] =
          (lastChanged as any) instanceof Date
            ? (lastChanged as any).toISOString().substr(0, 10)
            : lastChanged;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stations [Bahnhof] that match the specified organisational unit [Regionalbereich].
     * @param {string} [organisationalUnit] name of organisational unit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStationsByOrganisationalUnit: async (
      organisationalUnit?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/stations/by-organisational-unit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (organisationalUnit !== undefined) {
        localVarQueryParameter['organisationalUnit'] = organisationalUnit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StationsApi - functional programming interface
 * @export
 */
export const StationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStation(
      stationID: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Station>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStation(
        stationID,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all available stations [Bahnhöfe].
     * @param {string} [state] state [Bundesland] to limit search results for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStations(
      state?: string,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StationsPageable>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStations(
        state,
        locales,
        lastChanged,
        offset,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stations [Bahnhof] that match the specified organisational unit [Regionalbereich].
     * @param {string} [organisationalUnit] name of organisational unit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStationsByOrganisationalUnit(
      organisationalUnit?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stations>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStationsByOrganisationalUnit(
          organisationalUnit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StationsApi - factory interface
 * @export
 */
export const StationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StationsApiFp(configuration);
  return {
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStation(stationID: string, options?: any): AxiosPromise<Station> {
      return localVarFp
        .getStation(stationID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all available stations [Bahnhöfe].
     * @param {string} [state] state [Bundesland] to limit search results for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStations(
      state?: string,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<StationsPageable> {
      return localVarFp
        .getStations(state, locales, lastChanged, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stations [Bahnhof] that match the specified organisational unit [Regionalbereich].
     * @param {string} [organisationalUnit] name of organisational unit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStationsByOrganisationalUnit(
      organisationalUnit?: string,
      options?: any,
    ): AxiosPromise<Stations> {
      return localVarFp
        .getStationsByOrganisationalUnit(organisationalUnit, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getStation operation in StationsApi.
 * @export
 * @interface StationsApiGetStationRequest
 */
export interface StationsApiGetStationRequest {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiGetStation
   */
  readonly stationID: string;
}

/**
 * Request parameters for getStations operation in StationsApi.
 * @export
 * @interface StationsApiGetStationsRequest
 */
export interface StationsApiGetStationsRequest {
  /**
   * state [Bundesland] to limit search results for
   * @type {string}
   * @memberof StationsApiGetStations
   */
  readonly state?: string;

  /**
   * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
   * @type {Array<Locale>}
   * @memberof StationsApiGetStations
   */
  readonly locales?: Array<Locale>;

  /**
   * limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
   * @type {string}
   * @memberof StationsApiGetStations
   */
  readonly lastChanged?: string;

  /**
   * pagination offset parameter in order to navigate through result list, defaults to 0
   * @type {number}
   * @memberof StationsApiGetStations
   */
  readonly offset?: number;

  /**
   * pagination limit parameter in order to limit total amount of results, defaults to 100
   * @type {number}
   * @memberof StationsApiGetStations
   */
  readonly limit?: number;
}

/**
 * Request parameters for getStationsByOrganisationalUnit operation in StationsApi.
 * @export
 * @interface StationsApiGetStationsByOrganisationalUnitRequest
 */
export interface StationsApiGetStationsByOrganisationalUnitRequest {
  /**
   * name of organisational unit
   * @type {string}
   * @memberof StationsApiGetStationsByOrganisationalUnit
   */
  readonly organisationalUnit?: string;
}

/**
 * StationsApi - object-oriented interface
 * @export
 * @class StationsApi
 * @extends {BaseAPI}
 */
export class StationsApi extends BaseAPI {
  /**
   * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
   * @param {StationsApiGetStationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public getStation(
    requestParameters: StationsApiGetStationRequest,
    options?: AxiosRequestConfig,
  ) {
    return StationsApiFp(this.configuration)
      .getStation(requestParameters.stationID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all available stations [Bahnhöfe].
   * @param {StationsApiGetStationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public getStations(
    requestParameters: StationsApiGetStationsRequest = {},
    options?: AxiosRequestConfig,
  ) {
    return StationsApiFp(this.configuration)
      .getStations(
        requestParameters.state,
        requestParameters.locales,
        requestParameters.lastChanged,
        requestParameters.offset,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stations [Bahnhof] that match the specified organisational unit [Regionalbereich].
   * @param {StationsApiGetStationsByOrganisationalUnitRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public getStationsByOrganisationalUnit(
    requestParameters: StationsApiGetStationsByOrganisationalUnitRequest = {},
    options?: AxiosRequestConfig,
  ) {
    return StationsApiFp(this.configuration)
      .getStationsByOrganisationalUnit(
        requestParameters.organisationalUnit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StopPlacesApi - axios parameter creator
 * @export
 */
export const StopPlacesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlaceGroups: async (
      evaNumber: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getStopPlaceGroups', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}/groups`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlaceKeys: async (
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getStopPlaceKeys', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}/keys`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByEvaNumber: async (
      evaNumber: string,
      locales?: Array<Locale>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('getStopPlacesByEvaNumber', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number) - PLC (primary location code)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByKey: async (
      keyType: StopPlaceKeyFilter,
      key: string,
      locales?: Array<Locale>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('getStopPlacesByKey', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('getStopPlacesByKey', 'key', key);
      const localVarPath = `/stop-places/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for
     * @param {number} [latitude] optional geo reference position latitude, if provided results are also ranked by distance
     * @param {number} [longitude] optional geo reference position longitude, if provided results are also ranked by distance
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levenshtein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByName: async (
      query: string,
      latitude?: number,
      longitude?: number,
      state?: string,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('getStopPlacesByName', 'query', query);
      const localVarPath = `/stop-places/by-name/{query}`.replace(
        `{${'query'}}`,
        encodeURIComponent(String(query)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (transportAssociations) {
        localVarQueryParameter['transportAssociations'] = transportAssociations;
      }

      if (groupBy !== undefined) {
        localVarQueryParameter['groupBy'] = groupBy;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stop places [Haltestellen] around geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {number} [radius] radius in meters around geo position
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByPosition: async (
      latitude: number,
      longitude: number,
      state?: string,
      radius?: number,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'latitude' is not null or undefined
      assertParamExists('getStopPlacesByPosition', 'latitude', latitude);
      // verify required parameter 'longitude' is not null or undefined
      assertParamExists('getStopPlacesByPosition', 'longitude', longitude);
      const localVarPath = `/stop-places/by-position`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ClientId required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Client-Id',
        configuration,
      );

      // authentication ClientSecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter['radius'] = radius;
      }

      if (transportAssociations) {
        localVarQueryParameter['transportAssociations'] = transportAssociations;
      }

      if (groupBy !== undefined) {
        localVarQueryParameter['groupBy'] = groupBy;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StopPlacesApi - functional programming interface
 * @export
 */
export const StopPlacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StopPlacesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlaceGroups(
      evaNumber: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceGroups>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlaceGroups(evaNumber, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlaceKeys(
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaceKeys>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlaceKeys(
          evaNumber,
          keyType,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlacesByEvaNumber(
      evaNumber: string,
      locales?: Array<Locale>,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaces>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlacesByEvaNumber(
          evaNumber,
          locales,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number) - PLC (primary location code)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlacesByKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      locales?: Array<Locale>,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaces>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlacesByKey(
          keyType,
          key,
          locales,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for
     * @param {number} [latitude] optional geo reference position latitude, if provided results are also ranked by distance
     * @param {number} [longitude] optional geo reference position longitude, if provided results are also ranked by distance
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levenshtein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlacesByName(
      query: string,
      latitude?: number,
      longitude?: number,
      state?: string,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceSearchResults>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlacesByName(
          query,
          latitude,
          longitude,
          state,
          transportAssociations,
          groupBy,
          sortBy,
          onlyActive,
          locales,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stop places [Haltestellen] around geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {number} [radius] radius in meters around geo position
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStopPlacesByPosition(
      latitude: number,
      longitude: number,
      state?: string,
      radius?: number,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceSearchResults>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStopPlacesByPosition(
          latitude,
          longitude,
          state,
          radius,
          transportAssociations,
          groupBy,
          onlyActive,
          locales,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StopPlacesApi - factory interface
 * @export
 */
export const StopPlacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StopPlacesApiFp(configuration);
  return {
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlaceGroups(
      evaNumber: string,
      options?: any,
    ): AxiosPromise<StopPlaceGroups> {
      return localVarFp
        .getStopPlaceGroups(evaNumber, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlaceKeys(
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options?: any,
    ): AxiosPromise<StopPlaceKeys> {
      return localVarFp
        .getStopPlaceKeys(evaNumber, keyType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByEvaNumber(
      evaNumber: string,
      locales?: Array<Locale>,
      options?: any,
    ): AxiosPromise<StopPlaces> {
      return localVarFp
        .getStopPlacesByEvaNumber(evaNumber, locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number) - PLC (primary location code)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      locales?: Array<Locale>,
      options?: any,
    ): AxiosPromise<StopPlaces> {
      return localVarFp
        .getStopPlacesByKey(keyType, key, locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for
     * @param {number} [latitude] optional geo reference position latitude, if provided results are also ranked by distance
     * @param {number} [longitude] optional geo reference position longitude, if provided results are also ranked by distance
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levenshtein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByName(
      query: string,
      latitude?: number,
      longitude?: number,
      state?: string,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): AxiosPromise<StopPlaceSearchResults> {
      return localVarFp
        .getStopPlacesByName(
          query,
          latitude,
          longitude,
          state,
          transportAssociations,
          groupBy,
          sortBy,
          onlyActive,
          locales,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stop places [Haltestellen] around geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {string} [state] The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
     * @param {number} [radius] radius in meters around geo position
     * @param {Array<string>} [transportAssociations] transport associations [Verkehrsverbünde] to limit search results for
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
     * @param {Array<Locale>} [locales] Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStopPlacesByPosition(
      latitude: number,
      longitude: number,
      state?: string,
      radius?: number,
      transportAssociations?: Array<string>,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): AxiosPromise<StopPlaceSearchResults> {
      return localVarFp
        .getStopPlacesByPosition(
          latitude,
          longitude,
          state,
          radius,
          transportAssociations,
          groupBy,
          onlyActive,
          locales,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getStopPlaceGroups operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlaceGroupsRequest
 */
export interface StopPlacesApiGetStopPlaceGroupsRequest {
  /**
   * eva number to return stop place [Haltestelle] groups for
   * @type {string}
   * @memberof StopPlacesApiGetStopPlaceGroups
   */
  readonly evaNumber: string;
}

/**
 * Request parameters for getStopPlaceKeys operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlaceKeysRequest
 */
export interface StopPlacesApiGetStopPlaceKeysRequest {
  /**
   * eva number to return stop place [Haltestelle] keys for
   * @type {string}
   * @memberof StopPlacesApiGetStopPlaceKeys
   */
  readonly evaNumber: string;

  /**
   * filter mapped keys by specific key type, if omitted all keys are returned
   * @type {StopPlaceKeyType}
   * @memberof StopPlacesApiGetStopPlaceKeys
   */
  readonly keyType?: StopPlaceKeyType;
}

/**
 * Request parameters for getStopPlacesByEvaNumber operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlacesByEvaNumberRequest
 */
export interface StopPlacesApiGetStopPlacesByEvaNumberRequest {
  /**
   * eva number to return stop place [Haltestelle] for
   * @type {string}
   * @memberof StopPlacesApiGetStopPlacesByEvaNumber
   */
  readonly evaNumber: string;

  /**
   * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
   * @type {Array<Locale>}
   * @memberof StopPlacesApiGetStopPlacesByEvaNumber
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for getStopPlacesByKey operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlacesByKeyRequest
 */
export interface StopPlacesApiGetStopPlacesByKeyRequest {
  /**
   * type of stop place key - IFOPT (transmodel identifier for fixed objects aka DHID, may be provided on level of stop-place or plattform, other levels not supported yet) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (Stationsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number) - PLC (primary location code)
   * @type {StopPlaceKeyFilter}
   * @memberof StopPlacesApiGetStopPlacesByKey
   */
  readonly keyType: StopPlaceKeyFilter;

  /**
   * key to return stop places [Haltestellen] for
   * @type {string}
   * @memberof StopPlacesApiGetStopPlacesByKey
   */
  readonly key: string;

  /**
   * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
   * @type {Array<Locale>}
   * @memberof StopPlacesApiGetStopPlacesByKey
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for getStopPlacesByName operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlacesByNameRequest
 */
export interface StopPlacesApiGetStopPlacesByNameRequest {
  /**
   * query for stop place names [Haltestellenname] to search for
   * @type {string}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly query: string;

  /**
   * optional geo reference position latitude, if provided results are also ranked by distance
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly latitude?: number;

  /**
   * optional geo reference position longitude, if provided results are also ranked by distance
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly longitude?: number;

  /**
   * The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
   * @type {string}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly state?: string;

  /**
   * transport associations [Verkehrsverbünde] to limit search results for
   * @type {Array<string>}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly transportAssociations?: Array<string>;

  /**
   * group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
   * @type {StopPlaceSearchGroupByKey}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly groupBy?: StopPlaceSearchGroupByKey;

  /**
   * sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levenshtein Distance)
   * @type {StopPlaceSortKey}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly sortBy?: StopPlaceSortKey;

  /**
   * indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
   * @type {boolean}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly onlyActive?: boolean;

  /**
   * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
   * @type {Array<Locale>}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly locales?: Array<Locale>;

  /**
   * limit parameter in order to limit total amount of results, defaults to 25
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByName
   */
  readonly limit?: number;
}

/**
 * Request parameters for getStopPlacesByPosition operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGetStopPlacesByPositionRequest
 */
export interface StopPlacesApiGetStopPlacesByPositionRequest {
  /**
   * geo position latitude
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly latitude: number;

  /**
   * geo position longitude
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly longitude: number;

  /**
   * The state code [Bundeslandkürzel] the stop place belongs to. (Reference: https://www.datenportal.bmbf.de/portal/de/G122.html)
   * @type {string}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly state?: string;

  /**
   * radius in meters around geo position
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly radius?: number;

  /**
   * transport associations [Verkehrsverbünde] to limit search results for
   * @type {Array<string>}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly transportAssociations?: Array<string>;

  /**
   * group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - SALES (group defined by sales [Vertrieb], for instance FFM &#x3D; Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - NONE (no grouping is applied, just stop-places are returned)
   * @type {StopPlaceSearchGroupByKey}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly groupBy?: StopPlaceSearchGroupByKey;

  /**
   * indicates whether only active stop places should be returned (ie meaning that at least one transport is actually driving at this stop-place), defaults to true
   * @type {boolean}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly onlyActive?: boolean;

  /**
   * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)  *DE only*
   * @type {Array<Locale>}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly locales?: Array<Locale>;

  /**
   * limit parameter in order to limit total amount of results, if omitted no truncation applies
   * @type {number}
   * @memberof StopPlacesApiGetStopPlacesByPosition
   */
  readonly limit?: number;
}

/**
 * StopPlacesApi - object-oriented interface
 * @export
 * @class StopPlacesApi
 * @extends {BaseAPI}
 */
export class StopPlacesApi extends BaseAPI {
  /**
   * Returns all groups the stop place belongs with all group members.
   * @param {StopPlacesApiGetStopPlaceGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlaceGroups(
    requestParameters: StopPlacesApiGetStopPlaceGroupsRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlaceGroups(requestParameters.evaNumber, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
   * @param {StopPlacesApiGetStopPlaceKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlaceKeys(
    requestParameters: StopPlacesApiGetStopPlaceKeysRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlaceKeys(
        requestParameters.evaNumber,
        requestParameters.keyType,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
   * @param {StopPlacesApiGetStopPlacesByEvaNumberRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlacesByEvaNumber(
    requestParameters: StopPlacesApiGetStopPlacesByEvaNumberRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlacesByEvaNumber(
        requestParameters.evaNumber,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns stop places that match the provided key.
   * @param {StopPlacesApiGetStopPlacesByKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlacesByKey(
    requestParameters: StopPlacesApiGetStopPlacesByKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlacesByKey(
        requestParameters.keyType,
        requestParameters.key,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
   * @param {StopPlacesApiGetStopPlacesByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlacesByName(
    requestParameters: StopPlacesApiGetStopPlacesByNameRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlacesByName(
        requestParameters.query,
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.state,
        requestParameters.transportAssociations,
        requestParameters.groupBy,
        requestParameters.sortBy,
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stop places [Haltestellen] around geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhöfe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
   * @param {StopPlacesApiGetStopPlacesByPositionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public getStopPlacesByPosition(
    requestParameters: StopPlacesApiGetStopPlacesByPositionRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopPlacesApiFp(this.configuration)
      .getStopPlacesByPosition(
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.state,
        requestParameters.radius,
        requestParameters.transportAssociations,
        requestParameters.groupBy,
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
