/* tslint:disable */
/* eslint-disable */
/**
 * RIS :: Stations
 * ## Info * member of the **[RIS-API](https://db.de/ris-api)** family * powered by [DB Systel BusinessHub - doServices](https://user-portal.hub.ose.db.de/) * powered by [T.R Reisendeninformation](https://db-planet.deutschebahn.com/pages/reisendeninformation/apps/content/willkommen) * implements model: *1.0.201-SNAPSHOT*  ## Capabilities  ### Stations *stay tuned*  ### Travel Centers *stay tuned*  ### Stop Places Information on a huge amount of stop-places [Haltestellen] coming from different source like EFZ [Europäisches Fahrplanzentrum] and DB Station & Service. The service offers therefore all stop-place that are part or that were part of the official sales time table for germany including foreign stop-places for transpors driving into germany / leaving germany and connecting journeys in foreign countries that are part of the railteam alliance. OEPNV stop-places are returned as well.  Brief information for particular stop-place like * language dependent short, long, speech and symbol names from different sources [EFZ or BHW] * metropolis information [Metropole] * parent station [Bahnhof] * geo coordinates, country and timezone * transport types [Verkehrsmittel / Produkart] that depart / arrive * foreign key mappings [Fremdschluessel] like EVA, RL100 / DS100, EPA, IBNR, DHID / IFOPT, STADA and UIC * validity ranges [Gueltigkeitsbereiche]  Different query options for stop-places like * by name query with fuzzy-search [fehlertolerante Suche] and order by relevance [gewichtete Suche] * by geo-coordinate and radius ordered by distance * by foreign key  Multiple groups a stop-place may belong to like * Station [selber Bahnhof] * Sales [vertrieblicher Umsteigebereich inkl. OEPNV]  * Metropolitan Area [Stadtgebiet]  ### Platforms General information on platforms [Gleise, Bussteige, Plattformen etc.] for a particular stop-place like: * name, start and end in meters, linked platforms [selber Bahnsteig], parent platform [fuer Teilgleise]  * sectors with name, start and end in meters, cube position [Wuerfelposition] and information ob cube signage [Beschilderung] * accessibility information [Barrierefreier Zugang] like audible signals, automatic doors, stair markings and a lot more * informaton on operational platforms [Betriebsgleise], optics [Optiken], reference points [Refeenzpunkte] and orientations [Orientierung gemaess Nullpunkt]  ### Connecting-Times Connecting-times [Umsteigezeiten / Anschlusszeiten] for a stop-place [Haltestelle] and all members of stop-place group [Umsteigebereich] including foreign stop-places [Auslandshalte gemaess Railteam-Flag etc.]: * for different kind of stop-place groups    * Station [selber Bahnhof]   * Sales [vertrieblicher Umsteigebereich inkl. OEPNV]   * All [alle Umsteigebereiche] supported * and different personae, if available   * Occasional Traveller [Gelegenheitsreisender]   * Frequent Traveller [Pendler]   * Handicapped Traveller [Mobilitaetseingeschraenkter Reisender] * from various sources   * RIL420 [Konzernrichtlinie]   * EFZ [Europäisches Fahrplanzentrum inkl. OEPNV & Auslandshalte]   * IndoorRouting [Indoor Routing RIS-Maps] available  ## Limitations * *[backlog]* support active and inactive versions of stop-places/stations (differing date ranges) * *[backlog]* support foreign keys EPA & IBNR * *[backlog]* raise stop-place change events with RIS::Events in case stop-place data changes * *[backlog]* enable query of all stop-places that have been changed since a certain datetime * *[backlog]* include Station & Service Bahnhofswissen with it\'s fully functional API starting from ~Q1/Q2 2021  ## Getting Started * get to know the vision behind [RIS-API](https://db.de/ris-api) * visit our [Coding Dojo](https://ris.gitpages.tech.rz.db.de/risapi/documentation/) and learn how to get started  ## Licenses * The usage of the station data of DB Station & Services is subject to the Creative Commons Attribution 4.0 International (CC BY 4.0) license
 *
 * The version of the OpenAPI document: 1.0
 * Contact: BusinessHub.doServices.Titan.Team@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setSearchParams,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI } from './base';

/**
 * Accessibility [Barrierefreiheit] information for a particular platform.
 * @export
 * @interface Accessibility
 */
export interface Accessibility {
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  audibleSignalsAvailable?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  automaticDoor?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  boardingAid?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  passengerInformationDisplay?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  standardPlatformHeight?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  platformSign?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  stairsMarking?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  stepFreeAccess?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactileGuidingStrips?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactileHandrailLabel?: AccessibilityStatus;
  /**
   *
   * @type {AccessibilityStatus}
   * @memberof Accessibility
   */
  tactilePlatformAccess?: AccessibilityStatus;
}
/**
 * Status of platform accessibility [Barrierefreiheit] information. - AVAILABLE (accessibility item is available) - NOT_AVAILABLE (accessibility item is not available) - PARTIAL (accessibility item is only partial available, for instance availble for 12a but not for 12b and therefore not for 12 in total) - NOT_APPLICABLE (accessibility item is not applicable because it depends on availability of other items, for instance stair mark depends on step free access) - UNKNOWN (no information on availability for accessibility item)
 * @export
 * @enum {string}
 */

export enum AccessibilityStatus {
  Available = 'AVAILABLE',
  NotAvailable = 'NOT_AVAILABLE',
  Partial = 'PARTIAL',
  NotApplicable = 'NOT_APPLICABLE',
  Unknown = 'UNKNOWN',
}

/**
 * Address information with www info.
 * @export
 * @interface AddressWithWeb
 */
export interface AddressWithWeb {
  /**
   * Street name of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  street?: string;
  /**
   * Housenumber of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  houseNumber?: string;
  /**
   * Postalcode [Postleitzahl] of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  postalCode?: string;
  /**
   * City of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  city?: string;
  /**
   * State of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  state?: string;
  /**
   * Country of address the position should be retrived for.
   * @type {string}
   * @memberof AddressWithWeb
   */
  country?: string;
  /**
   * Web site for address.
   * @type {string}
   * @memberof AddressWithWeb
   */
  website?: string;
}
/**
 * Connecting time [Umsteigezeit] from a particular stop place [Haltestelle], platform [Gleis, Bahnsteig, Plattform] and optional sector [Gleisabschnitt, Steigabschnitt] to a particular station, platform and optional sector.
 * @export
 * @interface ConnectingTime
 */
export interface ConnectingTime {
  /**
   * Eva number of stop place [Haltestelle] to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromEvaNumber: string;
  /**
   * Platform [Gleis, Bahnsteig, Plattform] of stop place to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromPlatform?: string;
  /**
   * Sector [Gleisabschnitt, Steigabschnitt] of stop place to connect from.
   * @type {string}
   * @memberof ConnectingTime
   */
  fromSector?: string;
  /**
   * Eva number stop place to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toEvaNumber: string;
  /**
   * Platform [Gleis, Bahnsteig, Plattform] of stop place [Haltestelle] to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toPlatform?: string;
  /**
   * Sector [Gleisabschnitt, Steigabschnitt] of stop place [Haltestelle] to connect to.
   * @type {string}
   * @memberof ConnectingTime
   */
  toSector?: string;
  /**
   * Indicates whether connection takes place on the same physical platform [Bahnsteig] (platform \'12\' and \'13\' belong to physical platform \'12/13\' for instance).
   * @type {boolean}
   * @memberof ConnectingTime
   */
  identicalPhysicalPlatform: boolean;
  /**
   * Connecting times fo different personae.
   * @type {Array<ConnectionTime>}
   * @memberof ConnectingTime
   */
  times: Array<ConnectionTime>;
  /**
   *
   * @type {ConnectingTimeSource}
   * @memberof ConnectingTime
   */
  source: ConnectingTimeSource;
}
/**
 * Possible groups to consider when returning connecting-times for particular stop-place. - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. OEPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
 * @export
 * @enum {string}
 */

export enum ConnectingTimeGroup {
  Station = 'STATION',
  Sales = 'SALES',
  All = 'ALL',
}

/**
 * Enumerates all possible sources for connecting times [Umsteigezeiten]. - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ = Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
 * @export
 * @enum {string}
 */

export enum ConnectingTimeSource {
  Ril420 = 'RIL420',
  Efz = 'EFZ',
  IndoorRouting = 'INDOOR_ROUTING',
}

/**
 * Enumerates all possible sources to filter connecting times [Umsteigezeiten] for. - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ = Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
 * @export
 * @enum {string}
 */

export enum ConnectingTimeSourceFilter {
  Ril420 = 'RIL420',
  Efz = 'EFZ',
  IndoorRouting = 'INDOOR_ROUTING',
}

/**
 * List of connecting times [Umsteigezeiten] for requested list of stop-places [Haltestellen].
 * @export
 * @interface ConnectingTimesBatch
 */
export interface ConnectingTimesBatch {
  /**
   * List of connecting times.
   * @type {Array<ConnectingTime>}
   * @memberof ConnectingTimesBatch
   */
  connectingTimesList: Array<ConnectingTime>;
}
/**
 * Connecting time [Umsteigezeit] for a particular combination of stop-places, platforms and sectors.
 * @export
 * @interface ConnectingTimesSingle
 */
export interface ConnectingTimesSingle {
  /**
   * Fallback times for different personae in case no information is available.
   * @type {Array<ConnectionTimeFallback>}
   * @memberof ConnectingTimesSingle
   */
  fallbackTimes: Array<ConnectionTimeFallback>;
  /**
   *
   * @type {ConnectingTime}
   * @memberof ConnectingTimesSingle
   */
  connectingTime?: ConnectingTime;
}
/**
 * Connection time [Anschlusszeit] for persona.
 * @export
 * @interface ConnectionTime
 */
export interface ConnectionTime {
  /**
   *
   * @type {PersonaType}
   * @memberof ConnectionTime
   */
  persona: PersonaType;
  /**
   * Distance in meters.
   * @type {number}
   * @memberof ConnectionTime
   */
  distance?: number;
  /**
   * Duration of connect in ISO8601 (for instance \'P3Y6M4DT12H30M17S\').
   * @type {string}
   * @memberof ConnectionTime
   */
  duration: string;
}
/**
 * Fallback connection time [Anschlusszeit] for persona in case no information on stop-places and or plattform is available.
 * @export
 * @interface ConnectionTimeFallback
 */
export interface ConnectionTimeFallback {
  /**
   *
   * @type {PersonaType}
   * @memberof ConnectionTimeFallback
   */
  persona: PersonaType;
  /**
   * Duration of connect in ISO8601 (for instance \'P3Y6M4DT12H30M17S\').
   * @type {string}
   * @memberof ConnectionTimeFallback
   */
  duration: string;
  /**
   *
   * @type {ConnectingTimeSource}
   * @memberof ConnectionTimeFallback
   */
  source: ConnectingTimeSource;
}
/**
 * Contact details for public use.
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   * Name of a person.
   * @type {string}
   * @memberof Contact
   */
  contactPerson?: string;
  /**
   * further details of contact.
   * @type {string}
   * @memberof Contact
   */
  furtherDetails?: string;
  /**
   * phone number of contact.
   * @type {Array<PhoneNumber>}
   * @memberof Contact
   */
  phoneNumbers?: Array<PhoneNumber>;
  /**
   * EMail address in iso-format.
   * @type {string}
   * @memberof Contact
   */
  email?: string;
  /**
   * contact url.
   * @type {string}
   * @memberof Contact
   */
  url?: string;
}
/**
 * 2D coordinate within geo reference system.
 * @export
 * @interface Coordinate2D
 */
export interface Coordinate2D {
  /**
   * Longitude position in reference system.
   * @type {number}
   * @memberof Coordinate2D
   */
  longitude: number;
  /**
   * Latitude position in reference system.
   * @type {number}
   * @memberof Coordinate2D
   */
  latitude: number;
}
/**
 * Information on local service [Bahnhofsnahe Dienstleistungen].
 * @export
 * @interface LocalService
 */
export interface LocalService {
  /**
   * ID of the local service.
   * @type {string}
   * @memberof LocalService
   */
  localServiceID: string;
  /**
   * ID of the local service for external usage.
   * @type {string}
   * @memberof LocalService
   */
  externalID: string;
  /**
   * Type of local service. Possible values are - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
   * @type {string}
   * @memberof LocalService
   */
  type: string;
  /**
   * Name of the local service.
   * @type {string}
   * @memberof LocalService
   */
  name: string;
  /**
   * Description of the local service.
   * @type {string}
   * @memberof LocalService
   */
  description?: string;
  /**
   *
   * @type {AddressWithWeb}
   * @memberof LocalService
   */
  address?: AddressWithWeb;
  /**
   *
   * @type {Contact}
   * @memberof LocalService
   */
  contact?: Contact;
  /**
   * Opening times for local-service in OSM notation (see https://wiki.openstreetmap.org/wiki/DE:Key:opening_hours).
   * @type {string}
   * @memberof LocalService
   */
  openingHours?: string;
  /**
   * Date the local service is valid from.
   * @type {string}
   * @memberof LocalService
   */
  validFrom?: string;
  /**
   * Date the local service is valid to.
   * @type {string}
   * @memberof LocalService
   */
  validTo?: string;
  /**
   *
   * @type {Coordinate2D}
   * @memberof LocalService
   */
  position?: Coordinate2D;
}
/**
 * List of local services [Bahnhofsnahe Dienstleistungen].
 * @export
 * @interface LocalServices
 */
export interface LocalServices {
  /**
   * List of local services
   * @type {Array<LocalService>}
   * @memberof LocalServices
   */
  localServices: Array<LocalService>;
}
/**
 * Locale to use, defaults to DE. - DE (German) - EN (English) - FR (French) - IT (Italian)
 * @export
 * @enum {string}
 */

export enum Locale {
  De = 'DE',
  En = 'EN',
  Fr = 'FR',
  It = 'IT',
}

/**
 * Detailed operational [Betrieb] information.
 * @export
 * @interface Operational
 */
export interface Operational {
  /**
   * Total length of platform [Baulicher Bereich].
   * @type {number}
   * @memberof Operational
   */
  length?: number;
  /**
   * Orientation of the platform in degrees (north=0, east=90, ...), seen from the origin of the local coordinates.
   * @type {number}
   * @memberof Operational
   */
  orientation?: number;
  /**
   * Positions of the reference points that determine the position of a stopping train at the platform.
   * @type {Array<ReferencePoint>}
   * @memberof Operational
   */
  referencePoints?: Array<ReferencePoint>;
  /**
   * Names of the operational units [Optiken] that belong to the platform.
   * @type {Array<string>}
   * @memberof Operational
   */
  optics?: Array<string>;
  /**
   * Names of the network platforms [Netzgleis] that belong to the platform.
   * @type {Array<string>}
   * @memberof Operational
   */
  networkPlatforms?: Array<string>;
}
/**
 * Specifies different personae. - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
 * @export
 * @enum {string}
 */

export enum PersonaType {
  Handicapped = 'HANDICAPPED',
  OccasionalTraveller = 'OCCASIONAL_TRAVELLER',
  FrequentTraveller = 'FREQUENT_TRAVELLER',
}

/**
 * a phone number.
 * @export
 * @interface PhoneNumber
 */
export interface PhoneNumber {
  /**
   *
   * @type {PhoneNumberType}
   * @memberof PhoneNumber
   */
  type: PhoneNumberType;
  /**
   * phone number of contact.
   * @type {string}
   * @memberof PhoneNumber
   */
  number: string;
}
/**
 * Enumerates all phone types.
 * @export
 * @enum {string}
 */

export enum PhoneNumberType {
  Business = 'BUSINESS',
  Mobile = 'MOBILE',
  Fax = 'FAX',
}

/**
 * Platform [Gleis, Bahnsteig, Plattform] information. All ranges and positions of objects are given in meter in local coordinates, e.g. as a distance to a fixed point somewhere on the platform and differentiating between the two possible directions by a plus- and a minus-sign.
 * @export
 * @interface Platform
 */
export interface Platform {
  /**
   * Name of the platform (12, 1a, Nord, Süd etc.).
   * @type {string}
   * @memberof Platform
   */
  name: string;
  /**
   * Start of the usable part of the platform given in meter in local coordinates. This value may differ from zero and may be positive as well as negative.
   * @type {number}
   * @memberof Platform
   */
  start?: number;
  /**
   * End of the usable part of the platform given in meter in local coordinates.
   * @type {number}
   * @memberof Platform
   */
  end?: number;
  /**
   * Total length of platform [Baulicher Bereich].
   * @type {number}
   * @memberof Platform
   */
  length?: number;
  /**
   * List of platforms [Gleise] that share the same physical platform [Bahnsteig].
   * @type {Array<string>}
   * @memberof Platform
   */
  linkedPlatforms?: Array<string>;
  /**
   * Name of parent platform in case this is a subplatform [Teilgleis].
   * @type {string}
   * @memberof Platform
   */
  parentPlatform?: string;
  /**
   * Indicates whether platform is a head platform [Kopfgleis].
   * @type {boolean}
   * @memberof Platform
   */
  headPlatform?: boolean;
  /**
   * List of sectors [Sektoren] that belong to the platform.
   * @type {Array<Sector>}
   * @memberof Platform
   */
  sectors?: Array<Sector>;
  /**
   *
   * @type {Accessibility}
   * @memberof Platform
   */
  accessibility?: Accessibility;
  /**
   *
   * @type {Operational}
   * @memberof Platform
   */
  operational?: Operational;
}
/**
 * List of platforms [Gleise, Bahnsteige, Plattformen] for a station.
 * @export
 * @interface Platforms
 */
export interface Platforms {
  /**
   *
   * @type {Array<Platform>}
   * @memberof Platforms
   */
  platforms?: Array<Platform>;
}
/**
 * Reference point that indicates where a vehicle [Fahrzeug] stops at a platform [Gleis, Bahnsteig, Plattform].
 * @export
 * @interface ReferencePoint
 */
export interface ReferencePoint {
  /**
   * Unique ID of reference point.
   * @type {string}
   * @memberof ReferencePoint
   */
  uuid: string;
  /**
   * Name of the reference point.
   * @type {string}
   * @memberof ReferencePoint
   */
  name: string;
  /**
   *
   * @type {ReferencePointType}
   * @memberof ReferencePoint
   */
  referencePointType: ReferencePointType;
  /**
   * Position of the reference point in meter in local coordinates.
   * @type {number}
   * @memberof ReferencePoint
   */
  position: number;
  /**
   * Length up to the reference point is to be used by a stopping formation.
   * @type {number}
   * @memberof ReferencePoint
   */
  maxLength?: number;
  /**
   * Determines the direction the reference point is to be used. If true, the formation moves from origin to positive values in local coordinates.
   * @type {boolean}
   * @memberof ReferencePoint
   */
  readableFromOrigin: boolean;
}
/**
 * Type of a reference point. - STOP_SIGNAL (Haltesignal) - STOP_BOARD (Haltetafel)
 * @export
 * @enum {string}
 */

export enum ReferencePointType {
  Signal = 'STOP_SIGNAL',
  Board = 'STOP_BOARD',
}

/**
 * Platform [Gleis, Bahnsteig, Plattform] sector [Gleisabschnitt, Steigabschnitt] information.
 * @export
 * @interface Sector
 */
export interface Sector {
  /**
   * Name of the sector [Sektor / Mast etc.].
   * @type {string}
   * @memberof Sector
   */
  name: string;
  /**
   * Start of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  start: number;
  /**
   * End of the sector given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  end: number;
  /**
   * Position of the cube [Sektorwuerfel] given in meters in local coordinates.
   * @type {number}
   * @memberof Sector
   */
  cubePosition?: number;
  /**
   * Indicates whether cube [Sektorwuerfel] has signage [Beschilderung] nor not.
   * @type {boolean}
   * @memberof Sector
   */
  cubeSignage?: boolean;
}
/**
 * Base information for a station [Bahnhof].
 * @export
 * @interface Station
 */
export interface Station {
  /**
   * Unique id of station [Bahnhof], usually the STADA for S&S owned stations.
   * @type {string}
   * @memberof Station
   */
  stationID: string;
  /**
   * Language dependent names for a station, may contain different station names for a specific language depending on names filter.
   * @type {{ [key: string]: StationName; }}
   * @memberof Station
   */
  names: { [key: string]: StationName };
  /**
   * Language dependent names for metropolis [Metropole].
   * @type {{ [key: string]: string; }}
   * @memberof Station
   */
  metropolis?: { [key: string]: string };
  /**
   *
   * @type {AddressWithWeb}
   * @memberof Station
   */
  address: AddressWithWeb;
  /**
   *
   * @type {StationCategory}
   * @memberof Station
   */
  stationCategory?: StationCategory;
  /**
   * Available transport types [Verkehrsarten] at station.
   * @type {Array<TransportType>}
   * @memberof Station
   */
  availableTransports: Array<TransportType>;
  /**
   * All local services [Bahnhofsnahe Dienstleistungen] that are available at the station. - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
   * @type {Array<string>}
   * @memberof Station
   */
  availableLocalServices: Array<string>;
  /**
   *
   * @type {StationRoofingType}
   * @memberof Station
   */
  roofing?: StationRoofingType;
  /**
   *
   * @type {StationOwner}
   * @memberof Station
   */
  owner: StationOwner;
  /**
   * Opening times for station in OSM notation (see https://wiki.openstreetmap.org/wiki/DE:Key:opening_hours).
   * @type {string}
   * @memberof Station
   */
  openingHours?: string;
  /**
   * Country [Staat / Land] the station belongs to as ISO 3166-1 alpha-2 code [germany = \'DE\' for instance].
   * @type {string}
   * @memberof Station
   */
  countryCode: string;
  /**
   * Timezone the station belongs to, for instance \'Europe/Berlin\'. Must not necessarly be the time zone of the geo coordinate.
   * @type {string}
   * @memberof Station
   */
  timeZone: string;
  /**
   * Date the station is valid from.
   * @type {string}
   * @memberof Station
   */
  validFrom: string;
  /**
   * Date the station is valid to.
   * @type {string}
   * @memberof Station
   */
  validTo?: string;
  /**
   *
   * @type {Coordinate2D}
   * @memberof Station
   */
  position?: Coordinate2D;
}
/**
 * Category of station conforming to DB Station & Service..
 * @export
 * @enum {string}
 */

export enum StationCategory {
  _1 = 'CATEGORY_1',
  _2 = 'CATEGORY_2',
  _3 = 'CATEGORY_3',
  _4 = 'CATEGORY_4',
  _5 = 'CATEGORY_5',
  _6 = 'CATEGORY_6',
  _7 = 'CATEGORY_7',
}

/**
 * Key mapping for a station [Bahnhof].
 * @export
 * @interface StationKey
 */
export interface StationKey {
  /**
   *
   * @type {StationKeyType}
   * @memberof StationKey
   */
  type: StationKeyType;
  /**
   * Key value.
   * @type {string}
   * @memberof StationKey
   */
  key: string;
}
/**
 * Enumerates all identifiers a station [Bahnhof] can be mapped into or mapped from. - STADA (statitionsdatenbank number)
 * @export
 * @enum {string}
 */

export enum StationKeyType {
  Stada = 'STADA',
}

/**
 * Different key mappings a station [Bahnhof] may have.
 * @export
 * @interface StationKeys
 */
export interface StationKeys {
  /**
   * List of station keys.
   * @type {Array<StationKey>}
   * @memberof StationKeys
   */
  keys: Array<StationKey>;
}
/**
 * Name information for a station [Bahnhof].
 * @export
 * @interface StationName
 */
export interface StationName {
  /**
   * Name for station.
   * @type {string}
   * @memberof StationName
   */
  name: string;
}
/**
 * Station occupancy [Bahnhofauslastung] list for a week.
 * @export
 * @interface StationOccupancies
 */
export interface StationOccupancies {
  /**
   *
   * @type {Array<StationOccupancyPerDay>}
   * @memberof StationOccupancies
   */
  occupancies?: Array<StationOccupancyPerDay>;
}
/**
 * Possible station occupancy [Bahnhofauslastung] indications. - LESS_THAN_NORMAL (Less visitors than usual [Weniger Besucher als üblich]) - NORMAL (Usual number of visitors [Übliches Besucheraufkommen]) - MORE_THAN_NORMAL (More visitors than usual [Mehr Besucher als üblich]) - UNKNOWN (There is currently no information about the number of visitors [Es liegen zur Zeit keine Informationen über das Besucheraufkommen vor])
 * @export
 * @enum {string}
 */

export enum StationOccupancyIndicator {
  LessThanNormal = 'LESS_THAN_NORMAL',
  Normal = 'NORMAL',
  MoreThanNormal = 'MORE_THAN_NORMAL',
  Unknown = 'UNKNOWN',
}

/**
 * Station occupancy [Bahnhofauslastung] for a particular day.
 * @export
 * @interface StationOccupancyPerDay
 */
export interface StationOccupancyPerDay {
  /**
   * Start datetime of the occupancy for this particular day as fully qualified datetime (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof StationOccupancyPerDay
   */
  start: string;
  /**
   * End datetime of the occupancy for this particular day as fully qualified datetime (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof StationOccupancyPerDay
   */
  end: string;
  /**
   * Max value of the current occupancy for the timespan defined by start and end.
   * @type {number}
   * @memberof StationOccupancyPerDay
   */
  currentCountMax: number;
  /**
   * Max value of the average occupancy for the timespan defined by start and end.
   * @type {number}
   * @memberof StationOccupancyPerDay
   */
  averageCountMax: number;
  /**
   * List of occupancy time slots.
   * @type {Array<StationOccupancyTimeSlot>}
   * @memberof StationOccupancyPerDay
   */
  timeSlots: Array<StationOccupancyTimeSlot>;
}
/**
 * Station occupancy [Bahnhofauslastung] time slot with information about current and average counts.
 * @export
 * @interface StationOccupancyTimeSlot
 */
export interface StationOccupancyTimeSlot {
  /**
   * Start datetime of the occupancy for this particular time slot as fully qualified datetime (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof StationOccupancyTimeSlot
   */
  start: string;
  /**
   * End datetime of the occupancy for this particular time slot as fully qualified datetime (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
   * @type {string}
   * @memberof StationOccupancyTimeSlot
   */
  end: string;
  /**
   * Current occupancy of the time slot.
   * @type {number}
   * @memberof StationOccupancyTimeSlot
   */
  currentCount?: number;
  /**
   * Average occupancy of the time slot.
   * @type {number}
   * @memberof StationOccupancyTimeSlot
   */
  averageCount?: number;
  /**
   * Current occupancy percentage of the time slot.
   * @type {number}
   * @memberof StationOccupancyTimeSlot
   */
  currentPercentage?: number;
  /**
   *
   * @type {StationOccupancyIndicator}
   * @memberof StationOccupancyTimeSlot
   */
  value: StationOccupancyIndicator;
  /**
   * Language dependent occupancy level description.
   * @type {{ [key: string]: string; }}
   * @memberof StationOccupancyTimeSlot
   */
  descriptions: { [key: string]: string };
}
/**
 * Base information for a stations [Bahnhof] owner [Eigentümer / Betreiber].
 * @export
 * @interface StationOwner
 */
export interface StationOwner {
  /**
   * Name of owner
   * @type {string}
   * @memberof StationOwner
   */
  name: string;
}
/**
 * Defines station roofing [Bahnhofsueberdachung]. - COVERED [überdacht] - PARTIALLY_COVERED [teilweise überdacht] - NOT_COVERED [nicht überdacht]
 * @export
 * @enum {string}
 */

export enum StationRoofingType {
  Covered = 'COVERED',
  PartiallyCovered = 'PARTIALLY_COVERED',
  NotCovered = 'NOT_COVERED',
}

/**
 * Pageable stations search result.
 * @export
 * @interface StationsPageable
 */
export interface StationsPageable {
  /**
   * Pagination offset of the results, provided by the consumer.
   * @type {number}
   * @memberof StationsPageable
   */
  offset: number;
  /**
   * Maximum number of results that may be returned for one page, provided by the consumer.
   * @type {number}
   * @memberof StationsPageable
   */
  limit: number;
  /**
   * Total number of available results.
   * @type {number}
   * @memberof StationsPageable
   */
  total: number;
  /**
   *
   * @type {Array<Station>}
   * @memberof StationsPageable
   */
  stations?: Array<Station>;
}
/**
 * Base information for a stop place [Haltestelle].
 * @export
 * @interface StopPlace
 */
export interface StopPlace {
  /**
   * Eva number of stop place.
   * @type {string}
   * @memberof StopPlace
   */
  evaNumber: string;
  /**
   * ID of station [Bahnhof] the stop place belongs to [usually the STADA code for S&S], may be empty when stop place is not part of a station.
   * @type {string}
   * @memberof StopPlace
   */
  stationID?: string;
  /**
   * Language dependent names for stop place, may contain different stop place names for a specific language depending on names filter.
   * @type {{ [key: string]: StopPlaceName; }}
   * @memberof StopPlace
   */
  names: { [key: string]: StopPlaceName };
  /**
   * Language dependent name for metropolis [Metropole].
   * @type {{ [key: string]: string; }}
   * @memberof StopPlace
   */
  metropolis?: { [key: string]: string };
  /**
   * Available transport types [Verkehrsarten] at stop place.
   * @type {Array<TransportType>}
   * @memberof StopPlace
   */
  availableTransports: Array<TransportType>;
  /**
   * Country [Staat / Land] the stop place belongs to as ISO 3166-1 alpha-2 code [germany = \'DE\' for instance].
   * @type {string}
   * @memberof StopPlace
   */
  countryCode: string;
  /**
   * Timezone the stop place belongs to, for instance \'Europe/Berlin\'. Must not necessarly be the time zone of the geo coordinate.
   * @type {string}
   * @memberof StopPlace
   */
  timeZone: string;
  /**
   * Date the stop place is valid from.
   * @type {string}
   * @memberof StopPlace
   */
  validFrom?: string;
  /**
   * Date the stop place is valid to.
   * @type {string}
   * @memberof StopPlace
   */
  validTo?: string;
  /**
   *
   * @type {Coordinate2D}
   * @memberof StopPlace
   */
  position?: Coordinate2D;
}
/**
 * Group for stop places [Haltestellen] with all group members.
 * @export
 * @interface StopPlaceGroup
 */
export interface StopPlaceGroup {
  /**
   *
   * @type {StopPlaceGroupType}
   * @memberof StopPlaceGroup
   */
  type: StopPlaceGroupType;
  /**
   * List of stop place ids [Eva-Number] that belong to the group.
   * @type {Array<string>}
   * @memberof StopPlaceGroup
   */
  members: Array<string>;
}
/**
 * Possible groups [Station] a set of stop places [Haltestellen] may belong to. - STATION (group defined by station, for instance FFM = Hoch + Tief, maintained by S&S STADA hierachy) - SALES (group defined by sales [Vertrieb], for instance FFM = Hoch + Tief + Bus + Tram + Subway, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum]) - METROPOLITAN_AREA (group defined by sales [Vertrieb], for instance Stadtgebiet FFM = all big stations within FFM, maintained by DB Vertrieb via EFZ [Europäisches Fahrplanzentrum])
 * @export
 * @enum {string}
 */

export enum StopPlaceGroupType {
  Station = 'STATION',
  Sales = 'SALES',
  MetropolitanArea = 'METROPOLITAN_AREA',
}

/**
 * List of groups a stop place [Haltestelle] belongs to with all associated group members.
 * @export
 * @interface StopPlaceGroups
 */
export interface StopPlaceGroups {
  /**
   * List of groups the passed eva numbers belongs to including group members.
   * @type {Array<StopPlaceGroup>}
   * @memberof StopPlaceGroups
   */
  groups: Array<StopPlaceGroup>;
}
/**
 * Key mapping for a stop place [Haltestelle].
 * @export
 * @interface StopPlaceKey
 */
export interface StopPlaceKey {
  /**
   *
   * @type {StopPlaceKeyType}
   * @memberof StopPlaceKey
   */
  type: StopPlaceKeyType;
  /**
   * Key value.
   * @type {string}
   * @memberof StopPlaceKey
   */
  key: string;
}
/**
 * Enumerates all identifiers a stop-place [Haltestelle] can be mapped from. - IFOPT (transmodel identifier for fixed objects, in germany dhid = Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa uic number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.]) - UIC (international station number)
 * @export
 * @enum {string}
 */

export enum StopPlaceKeyFilter {
  Ifopt = 'IFOPT',
  Eva = 'EVA',
  Rl100 = 'RL100',
  Epa = 'EPA',
  Stada = 'STADA',
  Ibnr = 'IBNR',
  Ebhf = 'EBHF',
  Uic = 'UIC',
}

/**
 * Enumerates all identifiers a stop-place [Haltestelle] can be mapped into or mapped from. - IFOPT (transmodel identifier for fixed objects, in germany dhid = Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary rl100 / ds100) - RL100_ALTERNATIVE (alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.]) - UIC (international station number)
 * @export
 * @enum {string}
 */

export enum StopPlaceKeyType {
  Ifopt = 'IFOPT',
  Eva = 'EVA',
  Rl100 = 'RL100',
  Rl100Alternative = 'RL100_ALTERNATIVE',
  Epa = 'EPA',
  Stada = 'STADA',
  Ibnr = 'IBNR',
  Ebhf = 'EBHF',
  Uic = 'UIC',
}

/**
 * Different key mappings a stop place [Haltestelle] may have.
 * @export
 * @interface StopPlaceKeys
 */
export interface StopPlaceKeys {
  /**
   * List of stop place keys.
   * @type {Array<StopPlaceKey>}
   * @memberof StopPlaceKeys
   */
  keys: Array<StopPlaceKey>;
}
/**
 * Name information for stop place [Haltestelle].
 * @export
 * @interface StopPlaceName
 */
export interface StopPlaceName {
  /**
   * Full long name for stop place.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameLong: string;
  /**
   * Short name (max. 20 characters) for stop place, if available.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameShort?: string;
  /**
   * Name that is applicable for local areas, for instance \'Berlin Zoologischer Garten\' may become \'B Zoologischer Garten\'.
   * @type {string}
   * @memberof StopPlaceName
   */
  nameLocal?: string;
  /**
   * Long name speech information for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  speechLong?: string;
  /**
   * Short name speech information for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  speechShort?: string;
  /**
   * Symbol information [UTF-8] for stop place [Haltestelle].
   * @type {string}
   * @memberof StopPlaceName
   */
  symbol?: string;
}
/**
 * Different grouping options for stop places name query. - STATION (group by parent station that is defined by DB Station & Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
 * @export
 * @enum {string}
 */

export enum StopPlaceSearchGroupByKey {
  Station = 'STATION',
  None = 'NONE',
}

/**
 * Search result information for a stop place [Haltestelle].
 * @export
 * @interface StopPlaceSearchResult
 */
export interface StopPlaceSearchResult {
  /**
   * Eva number of stop place.
   * @type {string}
   * @memberof StopPlaceSearchResult
   */
  evaNumber: string;
  /**
   * ID of station [Bahnhof] the stop place belongs to [usually the STADA code for S&S], may be empty when stop place is not part of a station.
   * @type {string}
   * @memberof StopPlaceSearchResult
   */
  stationID?: string;
  /**
   * TBD
   * @type {Array<string>}
   * @memberof StopPlaceSearchResult
   */
  groupMembers: Array<string>;
  /**
   * Language dependent names for stop place.
   * @type {{ [key: string]: StopPlaceName; }}
   * @memberof StopPlaceSearchResult
   */
  names: { [key: string]: StopPlaceName };
  /**
   * Available transport types [Verkehrsarten] at stop place.
   * @type {Array<TransportType>}
   * @memberof StopPlaceSearchResult
   */
  availableTransports: Array<TransportType>;
  /**
   *
   * @type {Coordinate2D}
   * @memberof StopPlaceSearchResult
   */
  position?: Coordinate2D;
}
/**
 * Stop place [Haltestelle] search result.
 * @export
 * @interface StopPlaceSearchResults
 */
export interface StopPlaceSearchResults {
  /**
   *
   * @type {Array<StopPlaceSearchResult>}
   * @memberof StopPlaceSearchResults
   */
  stopPlaces?: Array<StopPlaceSearchResult>;
}
/**
 * Different sorting keys for stop place queries. - RELEVANCE (stop places are sorted by relevance descending (central stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query descending)
 * @export
 * @enum {string}
 */

export enum StopPlaceSortKey {
  Relevance = 'RELEVANCE',
  QueryMatch = 'QUERY_MATCH',
}

/**
 * Stop place [Haltestelle] result.
 * @export
 * @interface StopPlaces
 */
export interface StopPlaces {
  /**
   *
   * @type {Array<StopPlace>}
   * @memberof StopPlaces
   */
  stopPlaces?: Array<StopPlace>;
}
/**
 * Pageable stop place [Haltestelle] search result.
 * @export
 * @interface StopPlacesPageable
 */
export interface StopPlacesPageable {
  /**
   * Pagination offset of the results, provided by the consumer.
   * @type {number}
   * @memberof StopPlacesPageable
   */
  offset: number;
  /**
   * Maximum number of results that may be returned for one page, provided by the consumer.
   * @type {number}
   * @memberof StopPlacesPageable
   */
  limit: number;
  /**
   * Total number of available results.
   * @type {number}
   * @memberof StopPlacesPageable
   */
  total: number;
  /**
   *
   * @type {Array<StopPlace>}
   * @memberof StopPlacesPageable
   */
  stopPlaces?: Array<StopPlace>;
}
/**
 * Type of transport. - HIGH_SPEED_TRAIN (High speed train [Hochgeschwindigkeitszug] like ICE or TGV etc.) - INTERCITY_TRAIN (Inter city train [Intercityzug]) - INTER_REGIONAL_TRAIN (Inter regional train [Interregiozug]) - REGIONAL_TRAIN (Regional train [Regionalzug]) - CITY_TRAIN (City train [S-Bahn]) - SUBWAY (Subway [U-Bahn]) - TRAM (Tram [Strassenbahn]) - BUS (Bus [Bus]) - FERRY (Ferry [Faehre]) - FLIGHT (Flight [Flugzeug]) - CAR (Car [Auto]) - TAXI (Taxi) - SHUTTLE (Shuttle [Ruftaxi]) - BIKE ((E-)Bike [Fahrrad]) - SCOOTER ((E-)Scooter [Roller]) - WALK (Walk ([Laufen]) - UNKNOWN (Unknown)
 * @export
 * @enum {string}
 */

export enum TransportType {
  HighSpeedTrain = 'HIGH_SPEED_TRAIN',
  IntercityTrain = 'INTERCITY_TRAIN',
  InterRegionalTrain = 'INTER_REGIONAL_TRAIN',
  RegionalTrain = 'REGIONAL_TRAIN',
  CityTrain = 'CITY_TRAIN',
  Subway = 'SUBWAY',
  Tram = 'TRAM',
  Bus = 'BUS',
  Ferry = 'FERRY',
  Flight = 'FLIGHT',
  Car = 'CAR',
  Taxi = 'TAXI',
  Shuttle = 'SHUTTLE',
  Bike = 'BIKE',
  Scooter = 'SCOOTER',
  Walk = 'WALK',
  Unknown = 'UNKNOWN',
}

/**
 * ConnectingTimesApi - axios parameter creator
 * @export
 */
export const ConnectingTimesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a particular connecting time [Umsteigezeite] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platorms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platorm level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectingTime: async (
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fromEvaNumber' is not null or undefined
      assertParamExists('connectingTime', 'fromEvaNumber', fromEvaNumber);
      // verify required parameter 'toEvaNumber' is not null or undefined
      assertParamExists('connectingTime', 'toEvaNumber', toEvaNumber);
      const localVarPath = `/connecting-times/{fromEvaNumber}/{toEvaNumber}`
        .replace(
          `{${'fromEvaNumber'}}`,
          encodeURIComponent(String(fromEvaNumber)),
        )
        .replace(`{${'toEvaNumber'}}`, encodeURIComponent(String(toEvaNumber)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (fromPlatform !== undefined) {
        localVarQueryParameter['fromPlatform'] = fromPlatform;
      }

      if (fromSector !== undefined) {
        localVarQueryParameter['fromSector'] = fromSector;
      }

      if (toPlatform !== undefined) {
        localVarQueryParameter['toPlatform'] = toPlatform;
      }

      if (toSector !== undefined) {
        localVarQueryParameter['toSector'] = toSector;
      }

      if (personaTypes) {
        localVarQueryParameter['personaTypes'] = personaTypes;
      }

      if (source) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. OEPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned allthough the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectingTimes: async (
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('connectingTimes', 'evaNumber', evaNumber);
      const localVarPath = `/connecting-times/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (calculateSectors !== undefined) {
        localVarQueryParameter['calculateSectors'] = calculateSectors;
      }

      if (personaTypes) {
        localVarQueryParameter['personaTypes'] = personaTypes;
      }

      if (source) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectingTimesApi - functional programming interface
 * @export
 */
export const ConnectingTimesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConnectingTimesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a particular connecting time [Umsteigezeite] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platorms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platorm level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async connectingTime(
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConnectingTimesSingle>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.connectingTime(
        fromEvaNumber,
        toEvaNumber,
        fromPlatform,
        fromSector,
        toPlatform,
        toSector,
        personaTypes,
        source,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. OEPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned allthough the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async connectingTimes(
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConnectingTimesBatch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.connectingTimes(
        evaNumber,
        group,
        calculateSectors,
        personaTypes,
        source,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ConnectingTimesApi - factory interface
 * @export
 */
export const ConnectingTimesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConnectingTimesApiFp(configuration);
  return {
    /**
     * Returns a particular connecting time [Umsteigezeite] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platorms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
     * @param {string} fromEvaNumber eva number of desired origin stop place
     * @param {string} toEvaNumber eva number of desired destination stop place
     * @param {string} [fromPlatform] platform to calculate time origin, if omitted fallback structure will be used
     * @param {string} [fromSector] sector to calculate time origin, if omitted fallback is platform level
     * @param {string} [toPlatform] platform to calculate time destination, if omitted fallback structure will be used
     * @param {string} [toSector] sector to calculate times destination, if omitted fallback is platorm level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSource>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectingTime(
      fromEvaNumber: string,
      toEvaNumber: string,
      fromPlatform?: string,
      fromSector?: string,
      toPlatform?: string,
      toSector?: string,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSource>,
      options?: any,
    ): AxiosPromise<ConnectingTimesSingle> {
      return localVarFp
        .connectingTime(
          fromEvaNumber,
          toEvaNumber,
          fromPlatform,
          fromSector,
          toPlatform,
          toSector,
          personaTypes,
          source,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
     * @param {string} evaNumber eva number of desired origin stop place
     * @param {ConnectingTimeGroup} [group] stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. OEPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
     * @param {boolean} [calculateSectors] should connecting times be calculated based on sector level, otherwise platform level
     * @param {Array<PersonaType>} [personaTypes] persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
     * @param {Array<ConnectingTimeSourceFilter>} [source] sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned allthough the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectingTimes(
      evaNumber: string,
      group?: ConnectingTimeGroup,
      calculateSectors?: boolean,
      personaTypes?: Array<PersonaType>,
      source?: Array<ConnectingTimeSourceFilter>,
      options?: any,
    ): AxiosPromise<ConnectingTimesBatch> {
      return localVarFp
        .connectingTimes(
          evaNumber,
          group,
          calculateSectors,
          personaTypes,
          source,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for connectingTime operation in ConnectingTimesApi.
 * @export
 * @interface ConnectingTimesApiConnectingTimeRequest
 */
export interface ConnectingTimesApiConnectingTimeRequest {
  /**
   * eva number of desired origin stop place
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly fromEvaNumber: string;

  /**
   * eva number of desired destination stop place
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly toEvaNumber: string;

  /**
   * platform to calculate time origin, if omitted fallback structure will be used
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly fromPlatform?: string;

  /**
   * sector to calculate time origin, if omitted fallback is platform level
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly fromSector?: string;

  /**
   * platform to calculate time destination, if omitted fallback structure will be used
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly toPlatform?: string;

  /**
   * sector to calculate times destination, if omitted fallback is platorm level
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly toSector?: string;

  /**
   * persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
   * @type {Array<PersonaType>}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly personaTypes?: Array<PersonaType>;

  /**
   * sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING] - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
   * @type {Array<ConnectingTimeSource>}
   * @memberof ConnectingTimesApiConnectingTime
   */
  readonly source?: Array<ConnectingTimeSource>;
}

/**
 * Request parameters for connectingTimes operation in ConnectingTimesApi.
 * @export
 * @interface ConnectingTimesApiConnectingTimesRequest
 */
export interface ConnectingTimesApiConnectingTimesRequest {
  /**
   * eva number of desired origin stop place
   * @type {string}
   * @memberof ConnectingTimesApiConnectingTimes
   */
  readonly evaNumber: string;

  /**
   * stop place group [Bahnhof / Umsteigebereich] to consider connecting times for, defaults to SALES if omitted - STATION (return connecting-times for stop-place and all members of the same station [Bahnhof] - SALES (return connecting-times for stop-place and all members of the sales group [EFZ / Vertrieb inkl. OEPNV] - ALL (return connecting-times for stop-place and all members of all groups the stop-place belongs to [all we have]
   * @type {ConnectingTimeGroup}
   * @memberof ConnectingTimesApiConnectingTimes
   */
  readonly group?: ConnectingTimeGroup;

  /**
   * should connecting times be calculated based on sector level, otherwise platform level
   * @type {boolean}
   * @memberof ConnectingTimesApiConnectingTimes
   */
  readonly calculateSectors?: boolean;

  /**
   * persona types that should be returned (if more than 1 is available), defaults to all personae if omitted - HANDICAPPED (Handicaped [MER] slow traveller, not able to use stairs and escalators) - OCCASIONAL_TRAVELLER (Occasional traveller [Gelegenheits-Reisender / Standard-Reisender] having mean walking speed. This is the default traveller.) - FREQUENT_TRAVELLER (Frequent traveller [Pendler] having higher speed than occasional traveller.)
   * @type {Array<PersonaType>}
   * @memberof ConnectingTimesApiConnectingTimes
   */
  readonly personaTypes?: Array<PersonaType>;

  /**
   * sources for connecting-times to consider for building the result, if omitted the best available source will be returned [order is RIL420 &lt; EFZ &lt; INDOOR_ROUTING]; in case nothing can be found FALLBACK will be returned allthough the filter may not contain it - RIL420 (connecting time is based on DB guideline RIL420) - EFZ (connecting time is based on EFZ &#x3D; Europäisches Fahrplanzentrum) - INDOOR_ROUTING (connecting time is based on real indoor routing information from ris-maps system)
   * @type {Array<ConnectingTimeSourceFilter>}
   * @memberof ConnectingTimesApiConnectingTimes
   */
  readonly source?: Array<ConnectingTimeSourceFilter>;
}

/**
 * ConnectingTimesApi - object-oriented interface
 * @export
 * @class ConnectingTimesApi
 * @extends {BaseAPI}
 */
export class ConnectingTimesApi extends BaseAPI {
  /**
   * Returns a particular connecting time [Umsteigezeite] for a combination of from / to stop-place [Haltestelle] with optional consideration of platform [Gleis, Bahnsteig, Plattform] and sectors [Gleisabschnitt, Steigabschnitt]. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. In case the combination of from / to can\'t be found or we don\'t have detailed information for this combination, a fallback structure is returned that contains the best available information. Meaning if sectors can\'t be found, but platforms, we use them. If platorms can\'t be found, but stop-places we use them. If stop-places can\'t be found, we use the default connecting-time for fromEvaNumber.
   * @param {ConnectingTimesApiConnectingTimeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectingTimesApi
   */
  public connectingTime(
    requestParameters: ConnectingTimesApiConnectingTimeRequest,
    options?: any,
  ) {
    return ConnectingTimesApiFp(this.configuration)
      .connectingTime(
        requestParameters.fromEvaNumber,
        requestParameters.toEvaNumber,
        requestParameters.fromPlatform,
        requestParameters.fromSector,
        requestParameters.toPlatform,
        requestParameters.toSector,
        requestParameters.personaTypes,
        requestParameters.source,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns connecting times [Umsteigezeiten] matrix for a set of stop-places [Haltestellen] belonging to a particular group on a platform [Gleis, Bahnsteig, Plattform] or optional sector [Gleisabschnitt, Steigabschnitt] level. Source for connecting times is at least the DB guideline RIL420, if available information from the EFZ and in case of a digitialized station a real indoor mapping with different persona types. Returned connecting-times are not transitive, meaning if you ask for \'FFM Hbf\' you get all times starting from there for instance \'FFM Hbf\' to \'FFM Hbf (tief)\', and not the opposite direction from \'FFM Hbf (tief)\' to \'FFM Hbf\'. The returned information must be read in the following way: - find a combination of fromEvaNumber, fromPlatform, fromSector and toEvaNumber, toPlatform, toSector - if nothing found, try the same without the sector information - if nothing found, try the same without the platform information - if nothing found, try the same with fromEvaNumber = toEvaNumber
   * @param {ConnectingTimesApiConnectingTimesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectingTimesApi
   */
  public connectingTimes(
    requestParameters: ConnectingTimesApiConnectingTimesRequest,
    options?: any,
  ) {
    return ConnectingTimesApiFp(this.configuration)
      .connectingTimes(
        requestParameters.evaNumber,
        requestParameters.group,
        requestParameters.calculateSectors,
        requestParameters.personaTypes,
        requestParameters.source,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key the platforms belong to - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byKey1: async (
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('byKey1', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('byKey1', 'key', key);
      const localVarPath = `/platforms/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      if (includeSubPlatforms !== undefined) {
        localVarQueryParameter['includeSubPlatforms'] = includeSubPlatforms;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    platform: async (
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      onlyActive?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('platform', 'evaNumber', evaNumber);
      // verify required parameter 'platformName' is not null or undefined
      assertParamExists('platform', 'platformName', platformName);
      const localVarPath = `/platforms/{evaNumber}/{platformName}`
        .replace(`{${'evaNumber'}}`, encodeURIComponent(String(evaNumber)))
        .replace(
          `{${'platformName'}}`,
          encodeURIComponent(String(platformName)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    platforms: async (
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('platforms', 'evaNumber', evaNumber);
      const localVarPath = `/platforms/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (includeSectors !== undefined) {
        localVarQueryParameter['includeSectors'] = includeSectors;
      }

      if (includeAccessibility !== undefined) {
        localVarQueryParameter['includeAccessibility'] = includeAccessibility;
      }

      if (includeOperational !== undefined) {
        localVarQueryParameter['includeOperational'] = includeOperational;
      }

      if (includeSubPlatforms !== undefined) {
        localVarQueryParameter['includeSubPlatforms'] = includeSubPlatforms;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PlatformsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key the platforms belong to - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byKey1(
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platforms>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byKey1(
        keyType,
        key,
        includeSectors,
        includeAccessibility,
        includeOperational,
        includeSubPlatforms,
        onlyActive,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async platform(
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.platform(
        evaNumber,
        platformName,
        includeSectors,
        includeAccessibility,
        includeOperational,
        onlyActive,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async platforms(
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platforms>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.platforms(
        evaNumber,
        includeSectors,
        includeAccessibility,
        includeOperational,
        includeSubPlatforms,
        onlyActive,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PlatformsApiFp(configuration);
  return {
    /**
     * Returns platforms [Gleise, Plattformen] that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key the platforms belong to - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
     * @param {string} key key to return platforms for
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byKey1(
      keyType: StopPlaceKeyFilter,
      key: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): AxiosPromise<Platforms> {
      return localVarFp
        .byKey1(
          keyType,
          key,
          includeSectors,
          includeAccessibility,
          includeOperational,
          includeSubPlatforms,
          onlyActive,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {string} platformName name of desired platform
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    platform(
      evaNumber: string,
      platformName: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): AxiosPromise<Platform> {
      return localVarFp
        .platform(
          evaNumber,
          platformName,
          includeSectors,
          includeAccessibility,
          includeOperational,
          onlyActive,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
     * @param {string} evaNumber eva number of desired stop place [Haltestelle]
     * @param {boolean} [includeSectors] should sector information be included
     * @param {boolean} [includeAccessibility] should accessibility information [Barrierefreiheit] be included
     * @param {boolean} [includeOperational] should operational information [Betriebsinformationen] be included
     * @param {boolean} [includeSubPlatforms] should subplatforms [Teilgleise] be included
     * @param {boolean} [onlyActive] indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    platforms(
      evaNumber: string,
      includeSectors?: boolean,
      includeAccessibility?: boolean,
      includeOperational?: boolean,
      includeSubPlatforms?: boolean,
      onlyActive?: boolean,
      options?: any,
    ): AxiosPromise<Platforms> {
      return localVarFp
        .platforms(
          evaNumber,
          includeSectors,
          includeAccessibility,
          includeOperational,
          includeSubPlatforms,
          onlyActive,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for byKey1 operation in PlatformsApi.
 * @export
 * @interface PlatformsApiByKey1Request
 */
export interface PlatformsApiByKey1Request {
  /**
   * type of stop place key the platforms belong to - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer])
   * @type {StopPlaceKeyFilter}
   * @memberof PlatformsApiByKey1
   */
  readonly keyType: StopPlaceKeyFilter;

  /**
   * key to return platforms for
   * @type {string}
   * @memberof PlatformsApiByKey1
   */
  readonly key: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiByKey1
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiByKey1
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiByKey1
   */
  readonly includeOperational?: boolean;

  /**
   * should subplatforms [Teilgleise] be included
   * @type {boolean}
   * @memberof PlatformsApiByKey1
   */
  readonly includeSubPlatforms?: boolean;

  /**
   * indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
   * @type {boolean}
   * @memberof PlatformsApiByKey1
   */
  readonly onlyActive?: boolean;
}

/**
 * Request parameters for platform operation in PlatformsApi.
 * @export
 * @interface PlatformsApiPlatformRequest
 */
export interface PlatformsApiPlatformRequest {
  /**
   * eva number of desired stop place [Haltestelle]
   * @type {string}
   * @memberof PlatformsApiPlatform
   */
  readonly evaNumber: string;

  /**
   * name of desired platform
   * @type {string}
   * @memberof PlatformsApiPlatform
   */
  readonly platformName: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiPlatform
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiPlatform
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiPlatform
   */
  readonly includeOperational?: boolean;

  /**
   * indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
   * @type {boolean}
   * @memberof PlatformsApiPlatform
   */
  readonly onlyActive?: boolean;
}

/**
 * Request parameters for platforms operation in PlatformsApi.
 * @export
 * @interface PlatformsApiPlatformsRequest
 */
export interface PlatformsApiPlatformsRequest {
  /**
   * eva number of desired stop place [Haltestelle]
   * @type {string}
   * @memberof PlatformsApiPlatforms
   */
  readonly evaNumber: string;

  /**
   * should sector information be included
   * @type {boolean}
   * @memberof PlatformsApiPlatforms
   */
  readonly includeSectors?: boolean;

  /**
   * should accessibility information [Barrierefreiheit] be included
   * @type {boolean}
   * @memberof PlatformsApiPlatforms
   */
  readonly includeAccessibility?: boolean;

  /**
   * should operational information [Betriebsinformationen] be included
   * @type {boolean}
   * @memberof PlatformsApiPlatforms
   */
  readonly includeOperational?: boolean;

  /**
   * should subplatforms [Teilgleise] be included
   * @type {boolean}
   * @memberof PlatformsApiPlatforms
   */
  readonly includeSubPlatforms?: boolean;

  /**
   * indicates whether only active platforms should be returned, defaults to true, if false inactive and future platforms for different validility time ranges are returned
   * @type {boolean}
   * @memberof PlatformsApiPlatforms
   */
  readonly onlyActive?: boolean;
}

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
  /**
   * Returns platforms [Gleise, Plattformen] that match the provided key.
   * @param {PlatformsApiByKey1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public byKey1(requestParameters: PlatformsApiByKey1Request, options?: any) {
    return PlatformsApiFp(this.configuration)
      .byKey1(
        requestParameters.keyType,
        requestParameters.key,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        requestParameters.includeSubPlatforms,
        requestParameters.onlyActive,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns detailed information for a particular platform [Gleis, Plattform] and optional its sectors [Sektoren].
   * @param {PlatformsApiPlatformRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public platform(
    requestParameters: PlatformsApiPlatformRequest,
    options?: any,
  ) {
    return PlatformsApiFp(this.configuration)
      .platform(
        requestParameters.evaNumber,
        requestParameters.platformName,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        requestParameters.onlyActive,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all platforms [Gleise, Plattformen] and optional their sectors [Sektoren] for requested eva number.
   * @param {PlatformsApiPlatformsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlatformsApi
   */
  public platforms(
    requestParameters: PlatformsApiPlatformsRequest,
    options?: any,
  ) {
    return PlatformsApiFp(this.configuration)
      .platforms(
        requestParameters.evaNumber,
        requestParameters.includeSectors,
        requestParameters.includeAccessibility,
        requestParameters.includeOperational,
        requestParameters.includeSubPlatforms,
        requestParameters.onlyActive,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StationsApi - axios parameter creator
 * @export
 */
export const StationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all available stations [Bahnhoefe].
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    all1: async (
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/stations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (lastChanged !== undefined) {
        localVarQueryParameter['lastChanged'] =
          (lastChanged as any) instanceof Date
            ? (lastChanged as any).toISOString().substr(0, 10)
            : lastChanged;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stations [Bahnhof] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stations belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards. This query won\'t return stop-places, only stations.
     * @param {string} query query for station names [Bahnhofsname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stations matching query
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byName1: async (
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('byName1', 'query', query);
      const localVarPath = `/stations/by-name/{query}`.replace(
        `{${'query'}}`,
        encodeURIComponent(String(query)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter['radius'] = radius;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all known keys of specific key type for the station [Bahnhof] with the provided stationID.
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {StationKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys1: async (
      stationID: string,
      keyType?: StationKeyType,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('keys1', 'stationID', stationID);
      const localVarPath = `/stations/{stationID}/keys`.replace(
        `{${'stationID'}}`,
        encodeURIComponent(String(stationID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all local services [Bahnhofsnahe Dienstleistungen] for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {Array<string>} [types] supported types of local services of a station [Bahnhof] - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localServices: async (
      stationID: string,
      types?: Array<string>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('localServices', 'stationID', stationID);
      const localVarPath = `/stations/{stationID}/local-services`.replace(
        `{${'stationID'}}`,
        encodeURIComponent(String(stationID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns occupancy [Auslastung] for the station [Bahnhof] for requested stationID [BahnhofsID] for the current week or a period (max. 7 days).
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} [startDay] start date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {string} [endDay] end date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancy: async (
      stationID: string,
      startDay?: string,
      endDay?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('occupancy', 'stationID', stationID);
      const localVarPath = `/stations/{stationID}/occupancy`.replace(
        `{${'stationID'}}`,
        encodeURIComponent(String(stationID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (startDay !== undefined) {
        localVarQueryParameter['startDay'] =
          (startDay as any) instanceof Date
            ? (startDay as any).toISOString().substr(0, 10)
            : startDay;
      }

      if (endDay !== undefined) {
        localVarQueryParameter['endDay'] =
          (endDay as any) instanceof Date
            ? (endDay as any).toISOString().substr(0, 10)
            : endDay;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns occupancy [Auslastung] by day for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} day day (yyyy-mm-dd) of requested station occupancy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByDay: async (
      stationID: string,
      day: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('occupancyByDay', 'stationID', stationID);
      // verify required parameter 'day' is not null or undefined
      assertParamExists('occupancyByDay', 'day', day);
      const localVarPath = `/stations/{stationID}/occupancy/{day}`
        .replace(`{${'stationID'}}`, encodeURIComponent(String(stationID)))
        .replace(`{${'day'}}`, encodeURIComponent(String(day)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    station: async (
      stationID: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationID' is not null or undefined
      assertParamExists('station', 'stationID', stationID);
      const localVarPath = `/stations/{stationID}`.replace(
        `{${'stationID'}}`,
        encodeURIComponent(String(stationID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StationsApi - functional programming interface
 * @export
 */
export const StationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all available stations [Bahnhoefe].
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async all1(
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StationsPageable>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.all1(
        onlyActive,
        locales,
        lastChanged,
        offset,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stations [Bahnhof] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stations belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards. This query won\'t return stop-places, only stations.
     * @param {string} query query for station names [Bahnhofsname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stations matching query
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byName1(
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StationsPageable>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byName1(
        query,
        latitude,
        longitude,
        radius,
        onlyActive,
        locales,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all known keys of specific key type for the station [Bahnhof] with the provided stationID.
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {StationKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async keys1(
      stationID: string,
      keyType?: StationKeyType,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationKeys>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.keys1(
        stationID,
        keyType,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all local services [Bahnhofsnahe Dienstleistungen] for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {Array<string>} [types] supported types of local services of a station [Bahnhof] - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async localServices(
      stationID: string,
      types?: Array<string>,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalServices>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.localServices(
        stationID,
        types,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns occupancy [Auslastung] for the station [Bahnhof] for requested stationID [BahnhofsID] for the current week or a period (max. 7 days).
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} [startDay] start date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {string} [endDay] end date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async occupancy(
      stationID: string,
      startDay?: string,
      endDay?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StationOccupancies>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.occupancy(
        stationID,
        startDay,
        endDay,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns occupancy [Auslastung] by day for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} day day (yyyy-mm-dd) of requested station occupancy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async occupancyByDay(
      stationID: string,
      day: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StationOccupancyPerDay>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.occupancyByDay(
        stationID,
        day,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async station(
      stationID: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Station>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.station(
        stationID,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StationsApi - factory interface
 * @export
 */
export const StationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StationsApiFp(configuration);
  return {
    /**
     * Returns all available stations [Bahnhoefe].
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    all1(
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<StationsPageable> {
      return localVarFp
        .all1(onlyActive, locales, lastChanged, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stations [Bahnhof] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stations belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards. This query won\'t return stop-places, only stations.
     * @param {string} query query for station names [Bahnhofsname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stations matching query
     * @param {boolean} [onlyActive] indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byName1(
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): AxiosPromise<StationsPageable> {
      return localVarFp
        .byName1(
          query,
          latitude,
          longitude,
          radius,
          onlyActive,
          locales,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all known keys of specific key type for the station [Bahnhof] with the provided stationID.
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {StationKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys1(
      stationID: string,
      keyType?: StationKeyType,
      options?: any,
    ): AxiosPromise<StationKeys> {
      return localVarFp
        .keys1(stationID, keyType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all local services [Bahnhofsnahe Dienstleistungen] for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {Array<string>} [types] supported types of local services of a station [Bahnhof] - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localServices(
      stationID: string,
      types?: Array<string>,
      options?: any,
    ): AxiosPromise<LocalServices> {
      return localVarFp
        .localServices(stationID, types, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns occupancy [Auslastung] for the station [Bahnhof] for requested stationID [BahnhofsID] for the current week or a period (max. 7 days).
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} [startDay] start date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {string} [endDay] end date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancy(
      stationID: string,
      startDay?: string,
      endDay?: string,
      options?: any,
    ): AxiosPromise<StationOccupancies> {
      return localVarFp
        .occupancy(stationID, startDay, endDay, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns occupancy [Auslastung] by day for the station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {string} day day (yyyy-mm-dd) of requested station occupancy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    occupancyByDay(
      stationID: string,
      day: string,
      options?: any,
    ): AxiosPromise<StationOccupancyPerDay> {
      return localVarFp
        .occupancyByDay(stationID, day, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
     * @param {string} stationID id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    station(stationID: string, options?: any): AxiosPromise<Station> {
      return localVarFp
        .station(stationID, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for all1 operation in StationsApi.
 * @export
 * @interface StationsApiAll1Request
 */
export interface StationsApiAll1Request {
  /**
   * indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
   * @type {boolean}
   * @memberof StationsApiAll1
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StationsApiAll1
   */
  readonly locales?: Array<Locale>;

  /**
   * limits result to all stations that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stations are returned
   * @type {string}
   * @memberof StationsApiAll1
   */
  readonly lastChanged?: string;

  /**
   * pagination offset parameter in order to navigate through result list, defaults to 0
   * @type {number}
   * @memberof StationsApiAll1
   */
  readonly offset?: number;

  /**
   * pagination limit parameter in order to limit total amount of results, defaults to 100
   * @type {number}
   * @memberof StationsApiAll1
   */
  readonly limit?: number;
}

/**
 * Request parameters for byName1 operation in StationsApi.
 * @export
 * @interface StationsApiByName1Request
 */
export interface StationsApiByName1Request {
  /**
   * query for station names [Bahnhofsname] to search for, use * for wildcards if necessary
   * @type {string}
   * @memberof StationsApiByName1
   */
  readonly query: string;

  /**
   * optional geo reference position latitude
   * @type {number}
   * @memberof StationsApiByName1
   */
  readonly latitude?: number;

  /**
   * optional geo reference position longitude
   * @type {number}
   * @memberof StationsApiByName1
   */
  readonly longitude?: number;

  /**
   * optional radius in meters around geo reference position to search for stations matching query
   * @type {number}
   * @memberof StationsApiByName1
   */
  readonly radius?: number;

  /**
   * indicates whether only active stations should be returned, defaults to true, if false inactive and future stations for different validility time ranges are returned
   * @type {boolean}
   * @memberof StationsApiByName1
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StationsApiByName1
   */
  readonly locales?: Array<Locale>;

  /**
   * limit parameter in order to limit total amount of results, defaults to 25
   * @type {number}
   * @memberof StationsApiByName1
   */
  readonly limit?: number;
}

/**
 * Request parameters for keys1 operation in StationsApi.
 * @export
 * @interface StationsApiKeys1Request
 */
export interface StationsApiKeys1Request {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiKeys1
   */
  readonly stationID: string;

  /**
   * filter mapped keys by specific key type, if omitted all keys are returned
   * @type {StationKeyType}
   * @memberof StationsApiKeys1
   */
  readonly keyType?: StationKeyType;
}

/**
 * Request parameters for localServices operation in StationsApi.
 * @export
 * @interface StationsApiLocalServicesRequest
 */
export interface StationsApiLocalServicesRequest {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiLocalServices
   */
  readonly stationID: string;

  /**
   * supported types of local services of a station [Bahnhof] - MOBILITY [Mobilitätseingeschränkten-Service] - LOST_PROPERTY [Fundbuero] - INFORMATION [Information] - TRAVEL_CENTER [Reisezentrum] - VIDEO_TRAVEL_CENTER [Video Reisezentrum] - TRIPLE_S_CENTER [Information] - DB_LOUNGE [DB Lounge] - RAILWAY_MISSION [Bahnhofsmission] - CAR_HIRE [Mietwagen] - CYCLE_HIRE [Mieträder] - TAXI [Taxi Stand]
   * @type {Array<string>}
   * @memberof StationsApiLocalServices
   */
  readonly types?: Array<string>;
}

/**
 * Request parameters for occupancy operation in StationsApi.
 * @export
 * @interface StationsApiOccupancyRequest
 */
export interface StationsApiOccupancyRequest {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiOccupancy
   */
  readonly stationID: string;

  /**
   * start date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
   * @type {string}
   * @memberof StationsApiOccupancy
   */
  readonly startDay?: string;

  /**
   * end date (yyyy-mm-dd) of requested station occupancy [Bahnhofsauslastung].
   * @type {string}
   * @memberof StationsApiOccupancy
   */
  readonly endDay?: string;
}

/**
 * Request parameters for occupancyByDay operation in StationsApi.
 * @export
 * @interface StationsApiOccupancyByDayRequest
 */
export interface StationsApiOccupancyByDayRequest {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiOccupancyByDay
   */
  readonly stationID: string;

  /**
   * day (yyyy-mm-dd) of requested station occupancy
   * @type {string}
   * @memberof StationsApiOccupancyByDay
   */
  readonly day: string;
}

/**
 * Request parameters for station operation in StationsApi.
 * @export
 * @interface StationsApiStationRequest
 */
export interface StationsApiStationRequest {
  /**
   * id of desired station [Bahnhof], usually the STADA id from Station &amp; Service
   * @type {string}
   * @memberof StationsApiStation
   */
  readonly stationID: string;
}

/**
 * StationsApi - object-oriented interface
 * @export
 * @class StationsApi
 * @extends {BaseAPI}
 */
export class StationsApi extends BaseAPI {
  /**
   * Returns all available stations [Bahnhoefe].
   * @param {StationsApiAll1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public all1(requestParameters: StationsApiAll1Request = {}, options?: any) {
    return StationsApiFp(this.configuration)
      .all1(
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.lastChanged,
        requestParameters.offset,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stations [Bahnhof] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stations belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards. This query won\'t return stop-places, only stations.
   * @param {StationsApiByName1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public byName1(requestParameters: StationsApiByName1Request, options?: any) {
    return StationsApiFp(this.configuration)
      .byName1(
        requestParameters.query,
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.radius,
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all known keys of specific key type for the station [Bahnhof] with the provided stationID.
   * @param {StationsApiKeys1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public keys1(requestParameters: StationsApiKeys1Request, options?: any) {
    return StationsApiFp(this.configuration)
      .keys1(requestParameters.stationID, requestParameters.keyType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all local services [Bahnhofsnahe Dienstleistungen] for the station [Bahnhof] for requested stationID [BahnhofsID].
   * @param {StationsApiLocalServicesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public localServices(
    requestParameters: StationsApiLocalServicesRequest,
    options?: any,
  ) {
    return StationsApiFp(this.configuration)
      .localServices(
        requestParameters.stationID,
        requestParameters.types,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns occupancy [Auslastung] for the station [Bahnhof] for requested stationID [BahnhofsID] for the current week or a period (max. 7 days).
   * @param {StationsApiOccupancyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public occupancy(
    requestParameters: StationsApiOccupancyRequest,
    options?: any,
  ) {
    return StationsApiFp(this.configuration)
      .occupancy(
        requestParameters.stationID,
        requestParameters.startDay,
        requestParameters.endDay,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns occupancy [Auslastung] by day for the station [Bahnhof] for requested stationID [BahnhofsID].
   * @param {StationsApiOccupancyByDayRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public occupancyByDay(
    requestParameters: StationsApiOccupancyByDayRequest,
    options?: any,
  ) {
    return StationsApiFp(this.configuration)
      .occupancyByDay(
        requestParameters.stationID,
        requestParameters.day,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns details on station [Bahnhof] for requested stationID [BahnhofsID].
   * @param {StationsApiStationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StationsApi
   */
  public station(requestParameters: StationsApiStationRequest, options?: any) {
    return StationsApiFp(this.configuration)
      .station(requestParameters.stationID, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StopPlacesApi - axios parameter creator
 * @export
 */
export const StopPlacesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all available stop places.
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stop-places that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stop-places are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    all: async (
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/stop-places`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (lastChanged !== undefined) {
        localVarQueryParameter['lastChanged'] =
          (lastChanged as any) instanceof Date
            ? (lastChanged as any).toISOString().substr(0, 10)
            : lastChanged;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byEvaNumber: async (
      evaNumber: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('byEvaNumber', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byKey: async (
      keyType: StopPlaceKeyFilter,
      key: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyType' is not null or undefined
      assertParamExists('byKey', 'keyType', keyType);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('byKey', 'key', key);
      const localVarPath = `/stop-places/by-key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      if (key !== undefined) {
        localVarQueryParameter['key'] = key;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stop places matching query
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levensthein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byName: async (
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('byName', 'query', query);
      const localVarPath = `/stop-places/by-name/{query}`.replace(
        `{${'query'}}`,
        encodeURIComponent(String(query)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter['radius'] = radius;
      }

      if (groupBy !== undefined) {
        localVarQueryParameter['groupBy'] = groupBy;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of stop places [Haltestellen] arround geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byPosition: async (
      latitude: number,
      longitude: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'latitude' is not null or undefined
      assertParamExists('byPosition', 'latitude', latitude);
      // verify required parameter 'longitude' is not null or undefined
      assertParamExists('byPosition', 'longitude', longitude);
      const localVarPath = `/stop-places/by-position`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (latitude !== undefined) {
        localVarQueryParameter['latitude'] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter['longitude'] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter['radius'] = radius;
      }

      if (groupBy !== undefined) {
        localVarQueryParameter['groupBy'] = groupBy;
      }

      if (onlyActive !== undefined) {
        localVarQueryParameter['onlyActive'] = onlyActive;
      }

      if (locales) {
        localVarQueryParameter['locales'] = locales;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groups: async (
      evaNumber: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('groups', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}/groups`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys: async (
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'evaNumber' is not null or undefined
      assertParamExists('keys', 'evaNumber', evaNumber);
      const localVarPath = `/stop-places/{evaNumber}/keys`.replace(
        `{${'evaNumber'}}`,
        encodeURIComponent(String(evaNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication DB-Api-Key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'DB-Api-Key',
        configuration,
      );

      if (keyType !== undefined) {
        localVarQueryParameter['keyType'] = keyType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StopPlacesApi - functional programming interface
 * @export
 */
export const StopPlacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StopPlacesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all available stop places.
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stop-places that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stop-places are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async all(
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlacesPageable>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.all(
        onlyActive,
        locales,
        lastChanged,
        offset,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byEvaNumber(
      evaNumber: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaces>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byEvaNumber(
        evaNumber,
        onlyActive,
        locales,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaces>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byKey(
        keyType,
        key,
        onlyActive,
        locales,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stop places matching query
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levensthein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byName(
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceSearchResults>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byName(
        query,
        latitude,
        longitude,
        radius,
        groupBy,
        sortBy,
        onlyActive,
        locales,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of stop places [Haltestellen] arround geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async byPosition(
      latitude: number,
      longitude: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceSearchResults>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.byPosition(
        latitude,
        longitude,
        radius,
        groupBy,
        onlyActive,
        locales,
        limit,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async groups(
      evaNumber: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StopPlaceGroups>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.groups(
        evaNumber,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async keys(
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPlaceKeys>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.keys(
        evaNumber,
        keyType,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StopPlacesApi - factory interface
 * @export
 */
export const StopPlacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StopPlacesApiFp(configuration);
  return {
    /**
     * Returns all available stop places.
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {string} [lastChanged] limits result to all stop-places that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stop-places are returned
     * @param {number} [offset] pagination offset parameter in order to navigate through result list, defaults to 0
     * @param {number} [limit] pagination limit parameter in order to limit total amount of results, defaults to 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    all(
      onlyActive?: boolean,
      locales?: Array<Locale>,
      lastChanged?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<StopPlacesPageable> {
      return localVarFp
        .all(onlyActive, locales, lastChanged, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byEvaNumber(
      evaNumber: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options?: any,
    ): AxiosPromise<StopPlaces> {
      return localVarFp
        .byEvaNumber(evaNumber, onlyActive, locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns stop places that match the provided key.
     * @param {StopPlaceKeyFilter} keyType type of stop place key - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number)
     * @param {string} key key to return stop places [Haltestellen] for
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byKey(
      keyType: StopPlaceKeyFilter,
      key: string,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      options?: any,
    ): AxiosPromise<StopPlaces> {
      return localVarFp
        .byKey(keyType, key, onlyActive, locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
     * @param {string} query query for stop place names [Haltestellenname] to search for, use * for wildcards if necessary
     * @param {number} [latitude] optional geo reference position latitude
     * @param {number} [longitude] optional geo reference position longitude
     * @param {number} [radius] optional radius in meters around geo reference position to search for stop places matching query
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {StopPlaceSortKey} [sortBy] sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levensthein Distance)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, defaults to 25
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byName(
      query: string,
      latitude?: number,
      longitude?: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      sortBy?: StopPlaceSortKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): AxiosPromise<StopPlaceSearchResults> {
      return localVarFp
        .byName(
          query,
          latitude,
          longitude,
          radius,
          groupBy,
          sortBy,
          onlyActive,
          locales,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of stop places [Haltestellen] arround geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
     * @param {number} latitude geo position latitude
     * @param {number} longitude geo position longitude
     * @param {number} [radius] radius in meters around geo position
     * @param {StopPlaceSearchGroupByKey} [groupBy] group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
     * @param {boolean} [onlyActive] indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
     * @param {Array<Locale>} [locales] languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
     * @param {number} [limit] limit parameter in order to limit total amount of results, if omitted no truncation applies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    byPosition(
      latitude: number,
      longitude: number,
      radius?: number,
      groupBy?: StopPlaceSearchGroupByKey,
      onlyActive?: boolean,
      locales?: Array<Locale>,
      limit?: number,
      options?: any,
    ): AxiosPromise<StopPlaceSearchResults> {
      return localVarFp
        .byPosition(
          latitude,
          longitude,
          radius,
          groupBy,
          onlyActive,
          locales,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all groups the stop place belongs with all group members.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] groups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groups(evaNumber: string, options?: any): AxiosPromise<StopPlaceGroups> {
      return localVarFp
        .groups(evaNumber, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
     * @param {string} evaNumber eva number to return stop place [Haltestelle] keys for
     * @param {StopPlaceKeyType} [keyType] filter mapped keys by specific key type, if omitted all keys are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys(
      evaNumber: string,
      keyType?: StopPlaceKeyType,
      options?: any,
    ): AxiosPromise<StopPlaceKeys> {
      return localVarFp
        .keys(evaNumber, keyType, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for all operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiAllRequest
 */
export interface StopPlacesApiAllRequest {
  /**
   * indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
   * @type {boolean}
   * @memberof StopPlacesApiAll
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StopPlacesApiAll
   */
  readonly locales?: Array<Locale>;

  /**
   * limits result to all stop-places that have been changed (anything) after passed fully qualified date (YYYY-MM-dd), can be used to get deltas, if omitted all stop-places are returned
   * @type {string}
   * @memberof StopPlacesApiAll
   */
  readonly lastChanged?: string;

  /**
   * pagination offset parameter in order to navigate through result list, defaults to 0
   * @type {number}
   * @memberof StopPlacesApiAll
   */
  readonly offset?: number;

  /**
   * pagination limit parameter in order to limit total amount of results, defaults to 100
   * @type {number}
   * @memberof StopPlacesApiAll
   */
  readonly limit?: number;
}

/**
 * Request parameters for byEvaNumber operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiByEvaNumberRequest
 */
export interface StopPlacesApiByEvaNumberRequest {
  /**
   * eva number to return stop place [Haltestelle] for
   * @type {string}
   * @memberof StopPlacesApiByEvaNumber
   */
  readonly evaNumber: string;

  /**
   * indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
   * @type {boolean}
   * @memberof StopPlacesApiByEvaNumber
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StopPlacesApiByEvaNumber
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for byKey operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiByKeyRequest
 */
export interface StopPlacesApiByKeyRequest {
  /**
   * type of stop place key - IFOPT (transmodel identifier for fixed objects, in germany dhid &#x3D; Deutschlandweite Halt ID also known as global id) - EVA (eva number) - RL100 (primary or alternative rl100 / ds100) - EPA (epa number) - STADA (statitionsdatenbank number) - IBNR (internal station number [interne bahnhofsnummer]) - EBHF ([Tarifpunktnummer / Einheitliche Bahnhofsdatei Nr.] - UIC (international station number)
   * @type {StopPlaceKeyFilter}
   * @memberof StopPlacesApiByKey
   */
  readonly keyType: StopPlaceKeyFilter;

  /**
   * key to return stop places [Haltestellen] for
   * @type {string}
   * @memberof StopPlacesApiByKey
   */
  readonly key: string;

  /**
   * indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
   * @type {boolean}
   * @memberof StopPlacesApiByKey
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StopPlacesApiByKey
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for byName operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiByNameRequest
 */
export interface StopPlacesApiByNameRequest {
  /**
   * query for stop place names [Haltestellenname] to search for, use * for wildcards if necessary
   * @type {string}
   * @memberof StopPlacesApiByName
   */
  readonly query: string;

  /**
   * optional geo reference position latitude
   * @type {number}
   * @memberof StopPlacesApiByName
   */
  readonly latitude?: number;

  /**
   * optional geo reference position longitude
   * @type {number}
   * @memberof StopPlacesApiByName
   */
  readonly longitude?: number;

  /**
   * optional radius in meters around geo reference position to search for stop places matching query
   * @type {number}
   * @memberof StopPlacesApiByName
   */
  readonly radius?: number;

  /**
   * group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
   * @type {StopPlaceSearchGroupByKey}
   * @memberof StopPlacesApiByName
   */
  readonly groupBy?: StopPlaceSearchGroupByKey;

  /**
   * sorting for search results, if omitted RELEVANCE will be used - RELEVANCE (stop places are sorted by relevance descending (main stations etc. first)) - QUERY_MATCH (stop places are sorted by matching the provided query string descending aka Levensthein Distance)
   * @type {StopPlaceSortKey}
   * @memberof StopPlacesApiByName
   */
  readonly sortBy?: StopPlaceSortKey;

  /**
   * indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
   * @type {boolean}
   * @memberof StopPlacesApiByName
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StopPlacesApiByName
   */
  readonly locales?: Array<Locale>;

  /**
   * limit parameter in order to limit total amount of results, defaults to 25
   * @type {number}
   * @memberof StopPlacesApiByName
   */
  readonly limit?: number;
}

/**
 * Request parameters for byPosition operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiByPositionRequest
 */
export interface StopPlacesApiByPositionRequest {
  /**
   * geo position latitude
   * @type {number}
   * @memberof StopPlacesApiByPosition
   */
  readonly latitude: number;

  /**
   * geo position longitude
   * @type {number}
   * @memberof StopPlacesApiByPosition
   */
  readonly longitude: number;

  /**
   * radius in meters around geo position
   * @type {number}
   * @memberof StopPlacesApiByPosition
   */
  readonly radius?: number;

  /**
   * group returned stop-places by their parent station [Bahnhof], defaults to grouping by STATION if omitted - STATION (group by parent station that is defined by DB Station &amp; Services STADA-ID) - NONE (no grouping is applied, just stop-places are returned)
   * @type {StopPlaceSearchGroupByKey}
   * @memberof StopPlacesApiByPosition
   */
  readonly groupBy?: StopPlaceSearchGroupByKey;

  /**
   * indicates whether only active stop places should be returned, defaults to true, if false inactive and future stop places for different validility time ranges are returned
   * @type {boolean}
   * @memberof StopPlacesApiByPosition
   */
  readonly onlyActive?: boolean;

  /**
   * languages to include, defaults to DE only - DE (German) - EN (English) - FR (French) - IT (Italian)
   * @type {Array<Locale>}
   * @memberof StopPlacesApiByPosition
   */
  readonly locales?: Array<Locale>;

  /**
   * limit parameter in order to limit total amount of results, if omitted no truncation applies
   * @type {number}
   * @memberof StopPlacesApiByPosition
   */
  readonly limit?: number;
}

/**
 * Request parameters for groups operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiGroupsRequest
 */
export interface StopPlacesApiGroupsRequest {
  /**
   * eva number to return stop place [Haltestelle] groups for
   * @type {string}
   * @memberof StopPlacesApiGroups
   */
  readonly evaNumber: string;
}

/**
 * Request parameters for keys operation in StopPlacesApi.
 * @export
 * @interface StopPlacesApiKeysRequest
 */
export interface StopPlacesApiKeysRequest {
  /**
   * eva number to return stop place [Haltestelle] keys for
   * @type {string}
   * @memberof StopPlacesApiKeys
   */
  readonly evaNumber: string;

  /**
   * filter mapped keys by specific key type, if omitted all keys are returned
   * @type {StopPlaceKeyType}
   * @memberof StopPlacesApiKeys
   */
  readonly keyType?: StopPlaceKeyType;
}

/**
 * StopPlacesApi - object-oriented interface
 * @export
 * @class StopPlacesApi
 * @extends {BaseAPI}
 */
export class StopPlacesApi extends BaseAPI {
  /**
   * Returns all available stop places.
   * @param {StopPlacesApiAllRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public all(requestParameters: StopPlacesApiAllRequest = {}, options?: any) {
    return StopPlacesApiFp(this.configuration)
      .all(
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.lastChanged,
        requestParameters.offset,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns stop place for provided eva number. May return multiple stop places in case differing validity time ranges exist and the flag onlyValid = false.
   * @param {StopPlacesApiByEvaNumberRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public byEvaNumber(
    requestParameters: StopPlacesApiByEvaNumberRequest,
    options?: any,
  ) {
    return StopPlacesApiFp(this.configuration)
      .byEvaNumber(
        requestParameters.evaNumber,
        requestParameters.onlyActive,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns stop places that match the provided key.
   * @param {StopPlacesApiByKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public byKey(requestParameters: StopPlacesApiByKeyRequest, options?: any) {
    return StopPlacesApiFp(this.configuration)
      .byKey(
        requestParameters.keyType,
        requestParameters.key,
        requestParameters.onlyActive,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stop places [Haltestelle] matching the provided name query, optional limited to a max radius around a provided geo coordinate, ordered by relevance or name matching desc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\'). The query has support for fuzzy searching, means minimal typos are ignored even without providing wildcards.
   * @param {StopPlacesApiByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public byName(requestParameters: StopPlacesApiByNameRequest, options?: any) {
    return StopPlacesApiFp(this.configuration)
      .byName(
        requestParameters.query,
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.radius,
        requestParameters.groupBy,
        requestParameters.sortBy,
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of stop places [Haltestellen] arround geo position within provided radius ordered by distance asc and (configurable) grouped by stations [Bahnhoefe], if stop-places belong to a parent stations (like for instance \'Frankfurt Main Hbf\' and \'Frankfurt tief\' belong to \'Frankfurt Main Hbf\').
   * @param {StopPlacesApiByPositionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public byPosition(
    requestParameters: StopPlacesApiByPositionRequest,
    options?: any,
  ) {
    return StopPlacesApiFp(this.configuration)
      .byPosition(
        requestParameters.latitude,
        requestParameters.longitude,
        requestParameters.radius,
        requestParameters.groupBy,
        requestParameters.onlyActive,
        requestParameters.locales,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all groups the stop place belongs with all group members.
   * @param {StopPlacesApiGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public groups(requestParameters: StopPlacesApiGroupsRequest, options?: any) {
    return StopPlacesApiFp(this.configuration)
      .groups(requestParameters.evaNumber, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all known keys of specific key type for the stop place with the provided eva number. Take care that associated keys may belong to some kind of group [Station for instance] and that relations between keys are most likely n:m and not 1:1.
   * @param {StopPlacesApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopPlacesApi
   */
  public keys(requestParameters: StopPlacesApiKeysRequest, options?: any) {
    return StopPlacesApiFp(this.configuration)
      .keys(requestParameters.evaNumber, requestParameters.keyType, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
